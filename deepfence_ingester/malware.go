package main

import (
	"encoding/json"
	"fmt"

	"github.com/deepfence/ThreatMapper/deepfence_utils/directory"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type Malware struct {
	DocId               string            `json:"doc_id"`
	Timestamp           string            `json:"@timestamp"`
	Count               int               `json:"count,omitempty"`
	Reason              string            `json:"reason,omitempty"`
	Resource            string            `json:"resource"`
	Status              string            `json:"status"`
	Region              string            `json:"region"`
	AccountID           string            `json:"account_id"`
	Group               string            `json:"group"`
	Service             string            `json:"service"`
	Title               string            `json:"title"`
	ComplianceCheckType string            `json:"compliance_check_type"`
	CloudProvider       string            `json:"cloud_provider"`
	NodeName            string            `json:"node_name"`
	NodeID              string            `json:"node_id"`
	ScanID              string            `json:"scan_id"`
	Masked              string            `json:"masked"`
	Type                string            `json:"type"`
	ControlID           string            `json:"control_id"`
	LayerID             string            `json:"Image Layer ID,omitempty"`
	RuleName            string            `json:"Matched Rule Name,omitempty"`
	StringsToMatch      []string          `json:"Matched Part,omitempty"`
	CategoryName        []string          `json:"Category,omitempty"`
	Severity            string            `json:"Severity,omitempty"`
	SeverityScore       float64           `json:"Severity Score,omitempty"`
	FileSeverity        string            `json:"FileSeverity,omitempty"`
	FileSevScore        float64           `json:"File Severity Score,omitempty"`
	CompleteFilename    string            `json:"Full File Name,omitempty"`
	Meta                []string          `json:"rule meta,omitempty"`
	MetaRules           map[string]string `json:"rule metadata,omitempty"`
	Summary             string            `json:"Summary,omitempty"`
	Class               string            `json:"Class,omitempty"`
	TenantID            string            `json:"tenant_id"`
}

type MalwareStruct struct {
	RuleName     string            `json:"Matched Rule Name,omitempty"`
	Severity     string            `json:"Severity,omitempty"`
	FileSeverity string            `json:"FileSeverity,omitempty"`
	FileSevScore float64           `json:"File Severity Score,omitempty"`
	MetaRules    map[string]string `json:"rule metadata"`
	Meta         []string          `json:"rule meta"`
	Summary      string            `json:"Summary,omitempty"`
	Class        string            `json:"Class,omitempty"`
}

func (s *BulkProcessor) processMalware(malware []byte) {
	var data Malware
	err := json.Unmarshal(malware, &data)
	if err != nil {
		log.Errorf("error unmarshal malware: %s", err)
		return
	}

	// log.Info(toJSON(complianceStruct))

	s.Add(NewBulkRequest(data.TenantID, data.ToMap()))

}

func commitFuncMalware(ns string, data []map[string]interface{}) error {

	ctx := directory.NewAccountContext()
	driver, err := directory.Neo4jClient(ctx)
	session, err := driver.Session(neo4j.AccessModeWrite)

	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction()
	if err != nil {
		return err
	}
	defer tx.Close()

	malwareMap := []map[string]interface{}{}
	for _, i := range data {
		malware := map[string]interface{}{}
		match := i["StringsToMatch"].([]string)
		metaRules := i["MetaRules"].(map[string]string)
		meta := i["Meta"].([]string)
		categoryName := i["CategoryName"].([]string)

		for k, v := range i {
			if k == "StringsToMatch" || k == "MetaRules" || k == "Meta" || k == "CategoryName" {
				continue
			}
			malware[k] = v
		}

		for k, v := range metaRules {
			if k != "" && v != "" {
				key := fmt.Sprintf("%v[%v]", "metaRules", k)
				malware[key] = v
			}
		}

		for i, s := range match {
			key := fmt.Sprintf("%v[%v]", "match", i)
			malware[key] = s
		}

		for i, s := range meta {
			key := fmt.Sprintf("%v[%v]", "meta", i)
			malware[key] = s
		}

		for i, s := range categoryName {
			key := fmt.Sprintf("%v[%v]", "category", i)
			malware[key] = s
		}

		malware["rule_name"] = fmt.Sprintf("%v:%v", i["RuleName"], i["host_name"])
		malwareMap = append(malwareMap, malware)
	}

	if _, err = tx.Run("UNWIND $batch as row MERGE (n:Malware{node_id:row.rule_id}) MERGE (m:MalwareScan{node_id: row.scan_id, host_name: row.host_name, time_stamp: timestamp()}) MERGE (m) -[:DETECTED]-> (n) SET n+= row", map[string]interface{}{"batch": malwareMap}); err != nil {
		return err
	}

	if _, err = tx.Run("MATCH (n:MalwareScan) MERGE (m:Node{node_id: n.host_name}) MERGE (n) -[:SCANNED]-> (m)", map[string]interface{}{}); err != nil {
		return err
	}

	return tx.Commit()
}

func (c *Malware) ToMap() map[string]interface{} {
	out, err := json.Marshal(*c)
	if err != nil {
		return nil
	}
	bb := map[string]interface{}{}
	_ = json.Unmarshal(out, &bb)
	return bb
}
