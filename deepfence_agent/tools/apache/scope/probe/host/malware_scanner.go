package host

import (
	"bytes"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/Jeffail/tunny"
	log "github.com/sirupsen/logrus"
	"github.com/weaveworks/scope/common/xfer"
	pb "github.com/weaveworks/scope/proto"
	"google.golang.org/grpc"
)

const (
	ebpfMalwareSocketPath         = "/tmp/yara-hunter.sock"
	ssEbpfMalwareLogPath          = "/var/log/fenced/malwareScanner.log"
	defaultMalwareScanConcurrency = 1
	malwareScanIndexName          = "malware-scan"
	malwareScanLogsIndexName      = "malware-scan-logs"
)

var MalwareCertPath = "/etc/filebeat/filebeat.crt"

var (
	MalwareScanConcurrency    int
	MalwareGrpcScanWorkerPool *tunny.Pool
	MalwareMgmtConsoleUrl     string
	MalwareDeepfenceKey       string
	MalwareScanDir            string
)

type malwareScanParameters struct {
	client      pb.MalwareScannerClient
	req         pb.MalwareRequest
	controlArgs map[string]string
	hostName    string
	r           *Reporter
}

func init() {
	var err error
	MalwareScanConcurrency, err = strconv.Atoi(os.Getenv("SECRET_SCAN_CONCURRENCY"))
	if err != nil {
		MalwareScanConcurrency = defaultMalwareScanConcurrency
	}
	MalwareGrpcScanWorkerPool = tunny.NewFunc(MalwareScanConcurrency, getAndPublishMalwareScanResultsWrapper)
	MalwareMgmtConsoleUrl = os.Getenv("MGMT_CONSOLE_URL")
	consolePort := os.Getenv("MGMT_CONSOLE_PORT")
	if consolePort != "" && consolePort != "443" {
		MalwareMgmtConsoleUrl += ":" + consolePort
	}
	MalwareDeepfenceKey = os.Getenv("DEEPFENCE_KEY")
	if os.Getenv("DF_SERVERLESS") == "true" {
		MalwareCertPath = "/deepfence/etc/filebeat/filebeat.crt"
		MalwareScanDir = "/"
	} else {
		log.Info("the host mount dir is", HostMountDir)
		MalwareScanDir = HostMountDir
	}
}

func (r *Reporter) startMalwareScan(req xfer.Request) xfer.Response {
	log.Info("malware scan started")
	nodeType := fmt.Sprintf("%s", req.ControlArgs["node_type"])
	var greq pb.MalwareRequest
	if nodeType == nodeTypeContainer {
		containerID := fmt.Sprintf("%s", req.ControlArgs["container_id"])
		if containerID == "" {
			return xfer.ResponseErrorf("container_id is required")
		}
		greq = pb.MalwareRequest{Input: &pb.MalwareRequest_Container{
			Container: &pb.MalwareContainer{Id: containerID},
		}}
	} else if nodeType == nodeTypeImage {
		imageId := fmt.Sprintf("%s", req.ControlArgs["image_id"])
		if imageId == "" {
			return xfer.ResponseErrorf("image_id is required")
		}
		imageName := fmt.Sprintf("%s", req.ControlArgs["image_id"])
		greq = pb.MalwareRequest{Input: &pb.MalwareRequest_Image{
			Image: &pb.MalwareDockerImage{Id: imageId, Name: imageName},
		}}
	} else if nodeType == nodeTypeHost {
		//log.Info("malware scan started final ", nodeType, MalwareScanDir, HostMountDir, "hello")
		greq = pb.MalwareRequest{Input: &pb.MalwareRequest_Path{Path: MalwareScanDir}}
	}
	ssClient, err := newMalwareScannerClient()
	if err != nil {
		log.Error("error in getting ss client: %s", err.Error())
		return xfer.ResponseErrorf("error in getting ss client: %s", err.Error())
	}
	go MalwareGrpcScanWorkerPool.Process(malwareScanParameters{
		client:      ssClient,
		req:         greq,
		controlArgs: req.ControlArgs,
		hostName:    r.hostName,
		r:           r,
	})
	return xfer.Response{MalwareScanInfo: "Malwares scan started"}
}

func writeMalwareScanDataToFile(malwareScanMsg string, index string) error {
	scanFilename := getDfInstallDir() + "/var/log/fenced/malware-scan/malware_scan.log"
	scanStatusFilename := getDfInstallDir() + "/var/log/fenced/malware-scan-log/malware_scan_log.log"
	files := map[string]string{
		malwareScanIndexName:     scanFilename,
		malwareScanLogsIndexName: scanStatusFilename,
	}

	filename := files[index]
	err := os.MkdirAll(filepath.Dir(filename), 0755)
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return err
	}

	defer f.Close()

	malwareScanMsg = strings.Replace(malwareScanMsg, "\n", " ", -1)
	if _, err = f.WriteString(malwareScanMsg + "\n"); err != nil {
		return err
	}
	return nil
}

func getAndPublishMalwareScanResultsWrapper(scanParametersInterface interface{}) interface{} {
	scanParameters, ok := scanParametersInterface.(malwareScanParameters)
	if !ok {
		log.Error("Error reading input from grpc API")
		return nil
	}
	getAndPublishMalwareScanResults(scanParameters.client, scanParameters.req, scanParameters.controlArgs,
		scanParameters.hostName, scanParameters.r)
	return nil
}

func getAndPublishMalwareScanResults(client pb.MalwareScannerClient, req pb.MalwareRequest, controlArgs map[string]string, hostName string, r *Reporter) {
	log.Info("started malware scan result")
	var malwareScanLogDoc = make(map[string]interface{})
	malwareScanLogDoc["node_id"] = controlArgs["node_id"]
	malwareScanLogDoc["node_type"] = controlArgs["node_type"]
	malwareScanLogDoc["node_name"] = hostName
	malwareScanLogDoc["container_name"] = controlArgs["container_name"]
	malwareScanLogDoc["kubernetes_cluster_name"] = controlArgs["kubernetes_cluster_name"]
	malwareScanLogDoc["host_name"] = hostName
	malwareScanLogDoc["scan_id"] = controlArgs["scan_id"]
	malwareScanLogDoc["masked"] = "false"
	malwareScanLogDoc["scan_status"] = "IN_PROGRESS"
	malwareScanLogDoc["time_stamp"] = getMalwareTimestamp()
	malwareScanLogDoc["@timestamp"] = getMalwareCurrentTime()
	log.Info("started malware scan logic")
	byteJson, err := json.Marshal(malwareScanLogDoc)
	if err != nil {
		fmt.Println("Error marshalling json: ", err)
		return
	}
	err = writeMalwareScanDataToFile(string(byteJson), malwareScanLogsIndexName)
	if err != nil {
		fmt.Println("Error in sending data to malwareScanLogsIndex to mark in progress:" + err.Error())
	}
	//log.Info("started conrext background",context.Background(), req)
	res, err := client.FindMalwareInfo(context.Background(), &req)
	//log.Error("the error is",err)
	if req.GetPath() != "" && err == nil && res != nil {
		if MalwareScanDir == HostMountDir {
			for _, malware := range res.Malwares {
				malware.CompleteFilename = strings.Replace(malware.GetCompleteFilename(), HostMountDir, "", 1)
			}
		}
	}
	log.Info("started malware scan logic")
	timestamp := getMalwareTimestamp()
	currTime := getMalwareCurrentTime()
	if err != nil {
		malwareScanLogDoc["scan_status"] = "ERROR"
		malwareScanLogDoc["scan_message"] = err.Error()
		malwareScanLogDoc["time_stamp"] = getMalwareTimestamp()
		malwareScanLogDoc["@timestamp"] = getMalwareCurrentTime()
		byteJson, _ = json.Marshal(malwareScanLogDoc)
		writeMalwareScanDataToFile(string(byteJson), malwareScanLogsIndexName)
		return
	} else {
		log.Error("Number of results received from YaraHunter for scan id:" + controlArgs["scan_id"] + " - " + strconv.Itoa(len(res.Malwares)))
	}
	for _, malware := range res.Malwares {
		var malwareScanDoc = make(map[string]interface{})
		malwareScanDoc["node_id"] = controlArgs["node_id"]
		malwareScanDoc["node_type"] = controlArgs["node_type"]
		malwareScanDoc["node_name"] = hostName
		malwareScanDoc["masked"] = "false"
		malwareScanDoc["host_name"] = hostName
		malwareScanDoc["scan_id"] = controlArgs["scan_id"]
		malwareScanDoc["container_name"] = controlArgs["container_name"]
		malwareScanDoc["kubernetes_cluster_name"] = controlArgs["kubernetes_cluster_name"]
		malwareScanDoc["time_stamp"] = timestamp
		malwareScanDoc["@timestamp"] = currTime
		values := reflect.ValueOf(*malware)
		typeOfS := values.Type()
		for index := 0; index < values.NumField(); index++ {
			if values.Field(index).CanInterface() {
				malwareScanDoc[typeOfS.Field(index).Name] = values.Field(index).Interface()
			}
		}
		byteJson, err := json.Marshal(malwareScanDoc)
		if err != nil {
			log.Error("Error in marshalling malware result object to json:" + err.Error())
			return
		}
		// byteJson := formatToKafka(malwareScanDoc)
		err = writeMalwareScanDataToFile(string(byteJson), malwareScanIndexName)
		if err != nil {
			fmt.Println("Error in sending data to malwareScanIndex:" + err.Error())
		}
	}
	if err == nil {
		malwareScanLogDoc["scan_status"] = "COMPLETE"
	} else {
		malwareScanLogDoc["scan_status"] = "ERROR"
		malwareScanLogDoc["scan_message"] = err.Error()
	}
	malwareScanLogDoc["time_stamp"] = timestamp
	malwareScanLogDoc["@timestamp"] = currTime
	byteJson, err = json.Marshal(malwareScanLogDoc)
	if err != nil {
		log.Error("Error in marshalling malwareScanLogDoc to json:" + err.Error())
		return
	}
	err = writeMalwareScanDataToFile(string(byteJson), malwareScanLogsIndexName)
	if err != nil {
		fmt.Println("Error in sending data to secretScanLogsIndex:" + err.Error())
	}

}

func getMalwareTimestamp() int64 {
	return time.Now().UTC().UnixNano() / 1000000
}

func getMalwareCurrentTime() string {
	return time.Now().UTC().Format("2006-01-02T15:04:05.000") + "Z"
}

func ingestMalwareScanData(malwareScanMsg string, index string) error {
	malwareScanMsg = strings.Replace(malwareScanMsg, "\n", " ", -1)
	postReader := bytes.NewReader([]byte(malwareScanMsg))
	retryCount := 0
	httpClient, err := buildMalwareClient()
	if err != nil {
		log.Error("Error building http client " + err.Error())
		return err
	}
	for {
		httpReq, err := http.NewRequest("POST", "https://"+MalwareMgmtConsoleUrl+"/df-api/ingest?doc_type="+index, postReader)
		if err != nil {
			return err
		}
		httpReq.Close = true
		httpReq.Header.Add("deepfence-key", MalwareDeepfenceKey)
		resp, err := httpClient.Do(httpReq)
		if err != nil {
			return err
		}
		if resp.StatusCode == 200 {
			resp.Body.Close()
			break
		} else {
			if retryCount > 5 {
				errMsg := fmt.Sprintf("Unable to complete request. Got %d ", resp.StatusCode)
				resp.Body.Close()
				return errors.New(errMsg)
			}
			resp.Body.Close()
			retryCount += 1
			time.Sleep(5 * time.Second)
		}
	}
	return nil
}

func newMalwareScannerClient() (pb.MalwareScannerClient, error) {
	maxMsgSize := 1024 * 1024 * 100 // 100 mb
	conn, err := grpc.Dial("unix://"+ebpfMalwareSocketPath, grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(maxMsgSize)),
		grpc.WithAuthority("dummy"), grpc.WithInsecure())
	if err != nil {
		fmt.Printf("error in creating malware scanner client: %s\n", err.Error())
		return nil, err
	}
	return pb.NewMalwareScannerClient(conn), nil
}

func buildMalwareClient() (*http.Client, error) {
	// Set up our own certificate pool
	tlsConfig := &tls.Config{RootCAs: x509.NewCertPool(), InsecureSkipVerify: true}
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig:     tlsConfig,
			DisableKeepAlives:   false,
			MaxIdleConnsPerHost: 1024,
			DialContext: (&net.Dialer{
				Timeout:   15 * time.Minute,
				KeepAlive: 15 * time.Minute,
			}).DialContext,
			TLSHandshakeTimeout:   10 * time.Second,
			ResponseHeaderTimeout: 5 * time.Minute,
		},
		Timeout: 15 * time.Minute,
	}

	// Load our trusted certificate path
	pemData, err := ioutil.ReadFile(MalwareCertPath)
	if err != nil {
		return nil, err
	}
	ok := tlsConfig.RootCAs.AppendCertsFromPEM(pemData)
	if !ok {
		return nil, errors.New("unable to append certificates to PEM")
	}

	return client, nil
}
