package host

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/Jeffail/tunny"
	log "github.com/sirupsen/logrus"
	pb "github.com/weaveworks/scope/proto"
	"google.golang.org/grpc"

	ctl "github.com/deepfence/golang_deepfence_sdk/utils/controls"
)

const (
	ebpfMalwareSocketPath         = "/tmp/yara-hunter.sock"
	ssEbpfMalwareLogPath          = "/var/log/fenced/malwareScanner.log"
	defaultMalwareScanConcurrency = 1
)

var (
	MalwareCertPath           = "/etc/filebeat/filebeat.crt"
	malwareScanFilename       = getDfInstallDir() + "/var/log/fenced/malware-scan/malware_scan.log"
	malwareScanStatusFilename = getDfInstallDir() + "/var/log/fenced/malware-scan-log/malware_scan_log.log"
)

var (
	MalwareScanConcurrency    int
	MalwareGrpcScanWorkerPool *tunny.Pool
	MalwareMgmtConsoleUrl     string
	MalwareDeepfenceKey       string
	MalwareScanDir            string
)

type malwareScanParameters struct {
	client      pb.MalwareScannerClient
	req         *pb.MalwareRequest
	controlArgs map[string]string
	hostName    string
}

func init() {
	var err error
	MalwareScanConcurrency, err = strconv.Atoi(os.Getenv("MALWARE_SCAN_CONCURRENCY"))
	if err != nil {
		MalwareScanConcurrency = defaultMalwareScanConcurrency
	}
	MalwareGrpcScanWorkerPool = tunny.NewFunc(MalwareScanConcurrency,
		getAndPublishMalwareScanResultsWrapper)
	MalwareMgmtConsoleUrl = os.Getenv("MGMT_CONSOLE_URL")
	consolePort := os.Getenv("MGMT_CONSOLE_PORT")
	if consolePort != "" && consolePort != "443" {
		MalwareMgmtConsoleUrl += ":" + consolePort
	}
	MalwareDeepfenceKey = os.Getenv("DEEPFENCE_KEY")
	if os.Getenv("DF_SERVERLESS") == "true" {
		MalwareCertPath = "/deepfence/etc/filebeat/filebeat.crt"
		MalwareScanDir = "/"
	} else {
		MalwareScanDir = HostMountDir
	}
}

func StartMalwareScan(req ctl.StartMalwareScanRequest) error {
	log.Infof("Start malware scan: %v\n", req)
	var greq pb.MalwareRequest
	switch req.NodeType {
	case ctl.Container:
		greq = pb.MalwareRequest{
			Input: &pb.MalwareRequest_Container{
				Container: &pb.MalwareContainer{Id: req.BinArgs["node_id"]},
			},
			ScanId: req.BinArgs["scan_id"],
		}
	case ctl.Image:
		greq = pb.MalwareRequest{
			Input: &pb.MalwareRequest_Image{
				Image: &pb.MalwareDockerImage{Id: req.BinArgs["node_id"], Name: req.BinArgs["image_name"]},
			},
			ScanId: req.BinArgs["scan_id"],
		}
	case ctl.Host:
		greq = pb.MalwareRequest{
			Input:  &pb.MalwareRequest_Path{Path: MalwareScanDir},
			ScanId: req.BinArgs["scan_id"],
		}
	}

	ssClient, err := newMalwareScannerClient()
	if err != nil {
		return err
	}
	go MalwareGrpcScanWorkerPool.Process(malwareScanParameters{
		client:      ssClient,
		req:         &greq,
		controlArgs: req.BinArgs,
	})
	return nil
}

func getAndPublishMalwareScanResultsWrapper(scanParametersInterface interface{}) interface{} {
	scanParameters, ok := scanParametersInterface.(malwareScanParameters)
	if !ok {
		fmt.Println("Error reading input from grpc API")
		return nil
	}
	getAndPublishMalwareScanResults(scanParameters.client, scanParameters.req,
		scanParameters.controlArgs, scanParameters.hostName)
	return nil
}

func getAndPublishMalwareScanResults(client pb.MalwareScannerClient, req *pb.MalwareRequest, controlArgs map[string]string, hostName string) {
	res, err := client.FindMalwareInfo(context.Background(), req)
	if err != nil {
		fmt.Println("FindMalwareInfo error" + err.Error())
		return
	}
	fmt.Printf("Malware scan completed for scan id %s with input %+v\n", controlArgs["scan_id"], res.GetInput())

	// if req.GetPath() != "" && res != nil {
	// 	if MalwareScanDir == HostMountDir {
	// 		for _, malware := range res.Malwares {
	// 			malware.CompleteFilename = strings.Replace(malware.GetCompleteFilename(), HostMountDir, "", 1)
	// 		}
	// 	}
	// }

	// currTime := getMalwareCurrentTime()

	// fmt.Println("Number of results received from MalwareScanner for scan id:" +
	// 	controlArgs["scan_id"] + " - " + strconv.Itoa(len(res.Malwares)))

	// for _, malware := range res.Malwares {
	// 	var malwareScanDoc = make(map[string]interface{})
	// 	malwareScanDoc["masked"] = false
	// 	malwareScanDoc["scan_id"] = controlArgs["scan_id"]
	// 	malwareScanDoc["@timestamp"] = currTime
	// 	values := reflect.ValueOf(*malware)
	// 	typeOfS := values.Type()
	// 	for index := 0; index < values.NumField(); index++ {
	// 		if values.Field(index).CanInterface() {
	// 			malwareScanDoc[typeOfS.Field(index).Name] = values.Field(index).Interface()
	// 		}
	// 	}
	// 	byteJson, err := json.Marshal(malwareScanDoc)
	// 	if err != nil {
	// 		fmt.Println("Error marshalling json: ", err)
	// 		continue
	// 	}
	// 	err = writeMalwareScanDataToFile(string(byteJson), malwareScanFilename)
	// 	if err != nil {
	// 		fmt.Println("Error in sending data to malwareScanIndex:" + err.Error())
	// 	}
	// }
}

func getMalwareTimestamp() int64 {
	return time.Now().UTC().UnixNano() / 1000000
}

func getMalwareCurrentTime() string {
	return time.Now().UTC().Format("2006-01-02T15:04:05.000") + "Z"
}

func writeMalwareScanDataToFile(malwareScanMsg string, filename string) error {
	os.MkdirAll(filepath.Dir(filename), 0755)
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return err
	}

	defer f.Close()

	malwareScanMsg = strings.Replace(malwareScanMsg, "\n", " ", -1)
	if _, err = f.WriteString(malwareScanMsg + "\n"); err != nil {
		return err
	}
	return nil
}

func newMalwareScannerClient() (pb.MalwareScannerClient, error) {
	conn, err := grpc.Dial("unix://"+ebpfMalwareSocketPath, grpc.WithAuthority("dummy"),
		grpc.WithInsecure())
	if err != nil {
		fmt.Printf("error in creating malware scanner client: %s\n", err.Error())
		return nil, err
	}
	return pb.NewMalwareScannerClient(conn), nil
}

func GetMalwareScannerJobCount() int32 {
	conn, err := grpc.Dial("unix://"+ebpfMalwareSocketPath, grpc.WithAuthority("dummy"),
		grpc.WithInsecure())
	if err != nil {
		fmt.Printf("error in creating malware scanner client: %s\n", err.Error())
		return 0
	}
	client := pb.NewScannersClient(conn)
	jobReport, err := client.ReportJobsStatus(context.Background(), &pb.Empty{})
	if err != nil {
		return 0
	}
	return jobReport.RunningJobs
}
