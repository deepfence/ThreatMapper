package ingesters

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/deepfence/ThreatMapper/deepfence_utils/directory"
	"github.com/deepfence/ThreatMapper/deepfence_utils/utils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type MalwareScanStatus struct {
	Timestamp             time.Time `json:"@timestamp"`
	ContainerName         string    `json:"container_name"`
	HostName              string    `json:"host_name"`
	KubernetesClusterName string    `json:"kubernetes_cluster_name"`
	Masked                string    `json:"masked"`
	NodeID                string    `json:"node_id"`
	NodeName              string    `json:"node_name"`
	NodeType              string    `json:"node_type"`
	ScanID                string    `json:"scan_id"`
	ScanStatus            string    `json:"scan_status"`
}

type Malware struct {
	Timestamp             time.Time         `json:"@timestamp,omitempty"`
	ImageLayerID          string            `json:"ImageLayerId,omitempty"`
	Class                 string            `json:"Class,omitempty"`
	CompleteFilename      string            `json:"CompleteFilename,omitempty,omitempty"`
	FileSevScore          float64           `json:"FileSevScore,omitempty"`
	FileSeverity          string            `json:"FileSeverity,omitempty"`
	SeverityScore         float64           `json:"SeverityScore,omitempty"`
	Meta                  []string          `json:"Meta,omitempty"`
	MetaRules             map[string]string `json:"Meta Rules,omitempty"`
	Summary               string            `json:"Summary,omitempty"`
	RuleName              string            `json:"RuleName,omitempty"`
	StringsToMatch        []string          `json:"StringsToMatch,omitempty"`
	ContainerName         string            `json:"container_name,omitempty"`
	HostName              string            `json:"host_name,omitempty"`
	KubernetesClusterName string            `json:"kubernetes_cluster_name,omitempty"`
	Masked                string            `json:"masked,omitempty"`
	NodeID                string            `json:"node_id,omitempty"`
	NodeType              string            `json:"node_type,omitempty"`
	ScanID                string            `json:"scan_id,omitempty"`
}

func CommitFuncMalware(ns string, data []Malware) error {

	malwareMap := []map[string]interface{}{}
	for _, i := range data {
		malware := map[string]interface{}{}
		match := i.StringsToMatch
		metaRules := i.MetaRules
		meta := i.Meta
		malware["@timestamp"] = i.Timestamp
		malware["image_layer_id"] = i.ImageLayerID
		malware["class"] = i.Class
		malware["complete_file_name"] = i.CompleteFilename
		malware["file_sev_score"] = i.FileSevScore
		malware["file_severity"] = i.FileSeverity
		malware["severity_score"] = i.SeverityScore
		malware["summary"] = i.Summary
		malware["rule_name"] = i.RuleName
		malware["masked"] = i.Masked
		malware["node_id"] = i.NodeID
		malware["Timestamp"] = i.Timestamp
		malware["container_name"] = i.ContainerName
		malware["kubernetes_cluster_name"] = i.KubernetesClusterName
		malware["masked"] = i.Masked
		malware["node_id"] = i.NodeID
		malware["node_type"] = i.NodeType
		malware["scan_id"] = i.ScanID
		malware["malware_id"] = i.ScanID + i.NodeID + i.RuleName + i.NodeType + i.CompleteFilename
		for k, v := range metaRules {
			if k != "" && v != "" {
				key := fmt.Sprintf("%v[%v]", "metaRules", k)
				malware[key] = v
			}
		}

		for i, s := range match {
			key := fmt.Sprintf("%v[%v]", "match", i)
			malware[key] = s
		}

		for i, s := range meta {
			key := fmt.Sprintf("%v[%v]", "meta", i)
			malware[key] = s
		}
		malwareMap = append(malwareMap, malware)
	}

	fmt.Println("test malwaremap data", len(malwareMap))

	ctx := directory.NewContextWithNameSpace(directory.NamespaceID(ns))
	driver, err := directory.Neo4jClient(ctx)
	if err != nil {
		return err
	}

	session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction()
	if err != nil {
		return err
	}
	defer tx.Close()

	//if _, err = tx.Run(`
	//	UNWIND $batch as row
	//	MERGE (n:Malware{node_id:row.node_id})
	//	MERGE (m:MalwareScan{node_id: row.scan_id})
	//	WITH n, m, row
	//	MERGE (m) -[:DETECTED]-> (n)
	//	SET n+= row`,
	//	map[string]interface{}{"batch": malwareMap}); err != nil {
	//	return err
	//}
	fmt.Println("the error reached here is ")

	if _, err = tx.Run(`
        UNWIND $batch as row 
		MERGE (n:Malware{malware_id: row.malware_id}) 
        SET n += row
		WITH n, row
		MERGE (m:MalwareScan{node_id: row.scan_id })
		WITH n, m
		MERGE (m) -[:DETECTED]-> (n)`,
		map[string]interface{}{"batch": malwareMap}); err != nil {
		fmt.Println("the error reached here is ", err)
		return err
	}

	return tx.Commit()
}

func CommitFuncMalwareScanStatus(ns string, data []MalwareScanStatus) error {
	ctx := directory.NewContextWithNameSpace(directory.NamespaceID(ns))
	driver, err := directory.Neo4jClient(ctx)
	if err != nil {
		return err
	}

	session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction()
	if err != nil {
		return err
	}
	defer tx.Close()

	if _, err = tx.Run(`
		UNWIND $batch as row
		MERGE (n:MalwareScan{node_id: row.scan_id})
		SET n.status = row.scan_status, n.updated_at = TIMESTAMP()`,
		map[string]interface{}{"batch": statusesMalwareToMaps(data)}); err != nil {
		return err
	}

	return tx.Commit()
}

func statusesMalwareToMaps(data []MalwareScanStatus) []map[string]interface{} {
	statuses := []map[string]interface{}{}
	for _, i := range data {
		statuses = append(statuses, utils.ToMap(i))
	}
	return statuses
}

func (c Malware) ToMap() map[string]interface{} {
	out, err := json.Marshal(c)
	if err != nil {
		return nil
	}
	bb := map[string]interface{}{}
	_ = json.Unmarshal(out, &bb)
	return bb
}
