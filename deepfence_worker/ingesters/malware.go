package ingesters

import (
	"fmt"
	"hash/fnv"
	"time"

	"github.com/deepfence/ThreatMapper/deepfence_utils/directory"
	"github.com/deepfence/ThreatMapper/deepfence_utils/log"
	"github.com/deepfence/ThreatMapper/deepfence_utils/utils"
	ingestersUtil "github.com/deepfence/ThreatMapper/deepfence_utils/utils/ingesters"
	workerUtil "github.com/deepfence/ThreatMapper/deepfence_worker/utils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

func generateMalwareRuleId(metaRule ingestersUtil.MetaRules) string {
	return generateHashFromString(metaRule.Author + metaRule.Date + metaRule.RuleName + metaRule.Info + metaRule.Filetype + metaRule.Version)
}

func generateHashFromString(s string) string {
	h := fnv.New32a()
	h.Write([]byte(s))
	return fmt.Sprintf("%x", h.Sum32())
}

func CommitFuncMalware(ns string, data []ingestersUtil.Malware) error {
	ctx := directory.NewContextWithNameSpace(directory.NamespaceID(ns))
	driver, err := directory.Neo4jClient(ctx)
	if err != nil {
		return err
	}

	session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction(neo4j.WithTxTimeout(30 * time.Second))
	if err != nil {
		return err
	}
	defer tx.Close()

	dataMap, err := malwareToMaps(data, tx)
	if err != nil {
		return nil
	}

	if _, err = tx.Run(`
		UNWIND $batch as row WITH row.Rule as rule, row.Malware as malware
		MERGE (r:MalwareRule{rule_id:rule.rule_id})
		SET r += rule,
		    r.masked = COALESCE(r.masked, false),
		    r.updated_at = TIMESTAMP()
		WITH malware as row, r
		MERGE (n:Malware{node_id:row.node_id})
		SET n+= row,
		    n.masked = COALESCE(n.masked, r.masked, false),
		    n.updated_at = TIMESTAMP()
		WITH n, r, row
		MERGE (n)-[:IS]->(r)
		MERGE (m:MalwareScan{node_id: row.scan_id})
		WITH n, m
		MERGE (m) -[l:DETECTED]-> (n)
		SET l.masked = COALESCE(n.masked, false)`,
		map[string]interface{}{"batch": dataMap}); err != nil {
		return err
	}

	return tx.Commit()
}

func malwareToMaps(data []ingestersUtil.Malware,
	tx neo4j.Transaction) ([]map[string]map[string]interface{}, error) {
	var malwares []map[string]map[string]interface{}
	for _, i := range data {
		malware := utils.ToMap(i)
		delete(malware, "meta_rules")

		entityId := ""
		if _, ok := malware["scan_id"]; ok {
			scanId := malware["scan_id"].(string)
			var err error
			entityId, err = workerUtil.GetEntityIdFromScanID(scanId, string(utils.NEO4JMalwareScan), tx)
			if err != nil {
				log.Error().Msgf("Error in getting entityId: %v", err)
				return nil, err
			}
		}

		i.MetaRules.FileSeverity = malware["file_severity"].(string)
		i.MetaRules.RuleName = malware["rule_name"].(string)
		i.MetaRules.RuleID = generateMalwareRuleId(i.MetaRules)

		nodeId := generateHashFromString(fmt.Sprintf("%v:%v",
			i.MetaRules.RuleID, i.CompleteFilename))

		if len(entityId) > 0 {
			nodeId = nodeId + "_" + entityId
		}
		malware["node_id"] = nodeId

		malwares = append(malwares, map[string]map[string]interface{}{
			"Rule":    utils.ToMap(i.MetaRules),
			"Malware": malware,
		})
	}
	return malwares, nil
}
