package ingesters

import (
	"fmt"
	"hash/fnv"
	"time"

	"github.com/deepfence/golang_deepfence_sdk/utils/directory"
	"github.com/deepfence/golang_deepfence_sdk/utils/utils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type MalwareScanStatus struct {
	Timestamp   time.Time `json:"@timestamp"`
	ScanID      string    `json:"scan_id"`
	ScanStatus  string    `json:"scan_status"`
	ScanMessage string    `json:"scan_message"`
}

type MetaRules struct {
	RuleID       string `json:"rule_id"`
	RuleName     string `json:"rule_name"`
	Author       string `json:"author"`
	Date         string `json:"date"`
	Description  string `json:"description"`
	Filetype     string `json:"filetype"`
	Info         string `json:"info"`
	Version      string `json:"version"`
	Reference    string `json:"reference"`
	FileSeverity string `json:"file_severity"`
}

type Malware struct {
	FileSevScore     float64   `json:"file_sev_score"`
	ImageLayerID     string    `json:"image_layer_id"`
	MetaRules        MetaRules `json:"meta_rules"`
	SeverityScore    int       `json:"severity_score"`
	Masked           bool      `json:"masked"`
	RuleName         string    `json:"rule_name"`
	StringsToMatch   []string  `json:"strings_to_match"`
	FileSeverity     string    `json:"file_severity"`
	CompleteFilename string    `json:"complete_filename"`
	Meta             []string  `json:"meta"`
	Summary          string    `json:"summary"`
	Class            string    `json:"class"`
	ScanID           string    `json:"scan_id"`
	Timestamp        time.Time `json:"timestamp"`
}

func generateMalwareRuleId(metaRule MetaRules) string {
	return generateHashFromString(metaRule.Author + metaRule.Date + metaRule.RuleName + metaRule.Info + metaRule.Filetype + metaRule.Version)
}

func generateHashFromString(s string) string {
	h := fnv.New32a()
	h.Write([]byte(s))
	return fmt.Sprintf("%x", h.Sum32())
}

func CommitFuncMalware(ns string, data []Malware) error {
	ctx := directory.NewContextWithNameSpace(directory.NamespaceID(ns))
	driver, err := directory.Neo4jClient(ctx)
	if err != nil {
		return err
	}

	session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction(neo4j.WithTxTimeout(30 * time.Second))
	if err != nil {
		return err
	}
	defer tx.Close()

	if _, err = tx.Run(`
		UNWIND $batch as row WITH row.Rule as rule, row.Malware as malware
		MERGE (r:MalwareRule{rule_id:rule.rule_id})
		SET r+=rule WITH malware as row, r
		MERGE (n:Malware{node_id:row.node_id})
		SET n+= row
		WITH n, r, row
		MERGE (n)-[:IS]->(r)
		MERGE (m:MalwareScan{node_id: row.scan_id})
		WITH n, m
		MERGE (m) -[r:DETECTED]-> (n)
		SET r.masked = false`,
		map[string]interface{}{"batch": malwareToMaps(data)}); err != nil {
		return err
	}

	return tx.Commit()
}

func malwareToMaps(data []Malware) []map[string]map[string]interface{} {
	var malwares []map[string]map[string]interface{}
	for _, i := range data {
		malware := utils.ToMap(i)
		delete(malware, "meta_rules")

		i.MetaRules.FileSeverity = malware["file_severity"].(string)
		i.MetaRules.RuleName = malware["rule_name"].(string)
		i.MetaRules.RuleID = generateMalwareRuleId(i.MetaRules)
		malware["node_id"] = generateHashFromString(fmt.Sprintf("%v:%v", i.MetaRules.RuleID, i.CompleteFilename))
		malwares = append(malwares, map[string]map[string]interface{}{
			"Rule":    utils.ToMap(i.MetaRules),
			"Malware": malware,
		})
	}
	return malwares
}
