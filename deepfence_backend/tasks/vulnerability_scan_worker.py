from config.app import celery_app, app as flask_app
from models.user import User
from resource_models.node import Node
from utils.constants import REGISTRY_TYPE_DOCKER_PVT, REGISTRY_TYPE_ECR, REGISTRY_TYPE_HARBOR, NODE_TYPE_HOST, \
    SCOPE_HOST_API_CONTROL_URL, CVE_SCAN_LOGS_INDEX, CVE_SCAN_RUNNING_STATUS, REGISTRY_TYPE_AZURE, \
    CVE_SCAN_STATUS_UPLOAD_COMPLETE, CVE_SCAN_STATUS_ERROR, CVE_SCAN_STATUS_QUEUED, REGISTRY_TYPE_DOCKER_HUB, \
    REGISTRY_TYPE_QUAY, REGISTRY_TYPE_GITLAB, REGISTRY_TYPE_GCLOUD, REGISTRY_TYPE_JFROG, NODE_TYPE_CONTAINER_IMAGE, \
    CVE_SCAN_STATUS_WARN
from subprocess import Popen, PIPE
from utils.helper import call_scope_control_api, get_cve_scan_tmp_folder, md5_hash, rmdir_recursive, \
    store_vulnerability_log
from utils.esconn import ESConn
import json
import docker
from kubernetes import client as k8s_client, config as k8s_config
from datetime import datetime, timedelta
import time
import os
import requests

docker_orchestrator = "docker"
k8s_orchestrator = "kubernetes"


def cleanup(cve_node_id, registry_type, image_file_folder):
    if registry_type:
        try:
            docker_client = docker.from_env()
            docker_client.images.remove(image=cve_node_id)
        except Exception as ex:
            print(ex)
    if image_file_folder:
        rmdir_recursive(image_file_folder)
        try:
            requests.request("DEL", "https://deepfence-fetcher:8006/df-api/clear",
                             headers={"DF_FILE_NAME": image_file_folder},
                             verify=False)
        except:
            pass


@celery_app.task(bind=True, default_retry_delay=60)
def vulnerability_scan(self, **kwargs):
    log_file_name = ""
    deepfence_key = ""
    with flask_app.app_context():
        deepfence_key = User.query.filter_by(isActive=True).first().api_key
    scan_details = kwargs.get("scan_details", {})
    image_file_folder = ""
    """
    Figure out arguments for deepaudit 
    """
    mapper_image_name = os.environ.get("mapper_image_name", "deepfenceio/deepfence_vulnerability_mapper_ce")
    mapper_image_tag = os.environ.get("image_tag", "latest")
    mapper_image_name_with_tag = "{0}:{1}".format(mapper_image_name, mapper_image_tag)
    data_volume = {}
    update_dependency_data = "false"
    is_image_local = "false"
    docker_args = ""
    mgmt_console_url = os.environ.get("router_service", "127.0.0.1:443")

    k8s_namespace = os.environ.get("deepfence_namespace", "default")
    orchestrator = docker_orchestrator
    docker_client = None
    k8s_image_pull_secret_name = os.environ.get("k8s_image_pull_secret_name", "")
    if k8s_image_pull_secret_name:
        orchestrator = k8s_orchestrator
        # Load k8s in-cluster config
        k8s_config.load_incluster_config()

    if orchestrator == docker_orchestrator:
        fetcher_container_name = "deepfence-fetcher"
        try:
            docker_client = docker.from_env()
            containers = docker_client.containers.list(
                filters={"name": fetcher_container_name})
            for container in containers:
                if container.attrs.get("Name") == "/" + fetcher_container_name or container.attrs.get("Config", {}).get(
                        "Labels", {}).get("io.kubernetes.container.name", "") == fetcher_container_name:
                    for mount in container.attrs.get("Mounts", []):
                        if mount.get("Destination") == "/data":
                            mount_src = mount.get("Source", "")
                            if "/var/lib/docker/volumes/" in mount_src:
                                mount_src = mount_src.replace(
                                    "/var/lib/docker/volumes/", "").replace("/_data", "")
                            data_volume = {mount_src: {
                                'bind': mount.get("Destination"), 'mode': 'rw'}}
                            break
                    break
        except:
            pass

    if not data_volume:
        update_dependency_data = "true"
        is_image_local = "true"

    docker_volumes = {"/etc/docker/certs.d": {"bind": "/etc/docker/certs.d", "mode": "rw"},
                      "/var/run/docker.sock": {"bind": "/var/run/docker.sock", "mode": "rw"},
                      "/etc/containerd/certs.d": {"bind": "/etc/containerd/certs.d", "mode": "rw"},
                      "/run/containerd/containerd.sock": {"bind": "/run/containerd/containerd.sock", "mode": "rw"},
                      "/run/k3s/containerd/containerd.sock": {"bind": "/run/k3s/containerd/containerd.sock", "mode": "rw"},
                      "/var/lib/containerd": {"bind": "/var/lib/containerd", "mode": "rw"},
                      "/tmp": {"bind": "/tmp", "mode": "rw"},
                      **data_volume}
    docker_entrypoint = "/root/entrypoint.sh"

    scan_type = ",".join(scan_details.get("scan_types", []))
    # image_name_with_tag | host_name
    cve_node_id = scan_details["cve_node_id"]
    registry_type = scan_details.get("registry_type", None)
    credential_id = scan_details.get("credential_id", None)
    scan_id = scan_details["scan_id"]
    mask_cve_ids = scan_details.get("mask_cve_ids", "")
    hostname = ""
    node_type = NODE_TYPE_CONTAINER_IMAGE

    def add_scan_log(scan_message, scan_action, host_name, scan_node_type):
        scan_message = scan_message.replace("\n", " ")
        body = {
            "masked": "false", "type": CVE_SCAN_LOGS_INDEX, "scan_id": scan_id, "node_id": cve_node_id,
            "cve_scan_message": scan_message, "@timestamp": datetime.now().strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
            "host": host_name, "action": scan_action, "host_name": host_name, "time_stamp": int(time.time() * 1000.0),
            "node_type": scan_node_type,
        }
        ESConn.create_doc(CVE_SCAN_LOGS_INDEX,
                          body, refresh="wait_for")

    if registry_type in [REGISTRY_TYPE_ECR, REGISTRY_TYPE_HARBOR, REGISTRY_TYPE_DOCKER_PVT, REGISTRY_TYPE_AZURE,
                         REGISTRY_TYPE_DOCKER_HUB, REGISTRY_TYPE_QUAY, REGISTRY_TYPE_GITLAB, REGISTRY_TYPE_GCLOUD,
                         REGISTRY_TYPE_JFROG]:
        docker_entrypoint = "python3"
        docker_args_prefix = "registry_scan.py --scan_type '{0}' --image_name_with_tag '{1}' --registry_type '{2}' --scan_id '{3}' --mgmt_console_url '{4}' --credential_id '{5}'".format(
            scan_type, cve_node_id, registry_type, scan_id, mgmt_console_url, credential_id)

        docker_args = docker_args_prefix + " --deepfence_key '{0}' --update_dependency_data '{1}' --is_image_local {2}".format(
            deepfence_key, update_dependency_data, is_image_local)
        image_file_folder = get_cve_scan_tmp_folder("registry_scan", scan_id)
        log_file_name = cve_node_id
    else:
        node_id = scan_details["node_id"]
        node = Node(node_id)
        hostname = node.host_name
        kubernetes_cluster_name = node.kubernetes_cluster_name
        image_or_host = "host"
        if node.type == NODE_TYPE_HOST:
            node_type = NODE_TYPE_HOST
        else:
            image_or_host = cve_node_id
        log_file_name = image_or_host

        cve_status = node.get_cve_status().get("action", None)
        if cve_status in CVE_SCAN_RUNNING_STATUS:
            if node.type == NODE_TYPE_HOST:
                add_scan_log("Scan already running for this host",
                             CVE_SCAN_STATUS_ERROR, hostname, node_type)
            else:
                add_scan_log("Scan already running for this image",
                             CVE_SCAN_STATUS_ERROR, hostname, node_type)
            return
        image_file_folder = get_cve_scan_tmp_folder(hostname, scan_id)
        image_file_path = image_file_folder + "/layer.tar"
        upload_trigger_url = SCOPE_HOST_API_CONTROL_URL.format(probe_id=node.probe_id, host_name=hostname,
                                                               action="uploadData")
        # Trigger the host to upload image to console vm
        json_data = {"image_name": image_or_host, "scan_type": scan_type, "scan_id": scan_id,
                     "image_id": node.image_id, "kubernetes_cluster_name": kubernetes_cluster_name}
        resp_status, resp, status_code = call_scope_control_api(upload_trigger_url, hostname,
                                                                data=json.dumps(json_data))
        if not resp_status:
            add_scan_log(str(resp), CVE_SCAN_STATUS_ERROR, hostname, node_type)
            cleanup(cve_node_id, registry_type, image_file_folder)
            return
        add_scan_log("Image upload starting",
                     CVE_SCAN_STATUS_QUEUED, hostname, node_type)
        start_time = datetime.now()
        while True:
            cve_status = node.get_cve_status()
            curr_dt = datetime.now()
            if cve_status.get("scan_id", None) == scan_id:
                if cve_status.get("action", None) == CVE_SCAN_STATUS_UPLOAD_COMPLETE:
                    break
                # If no status update in the past 5 min, it has failed. We send it every 2 min
                if cve_status.get("@timestamp", None):
                    cve_status_date = datetime.strptime(
                        cve_status["@timestamp"], "%Y-%m-%dT%H:%M:%S.%fZ")
                    if (curr_dt - cve_status_date) > timedelta(minutes=5):
                        add_scan_log("Image upload failed",
                                     CVE_SCAN_STATUS_WARN, hostname, node_type)
                        # add_scan_log("Image upload failed", CVE_SCAN_STATUS_ERROR, hostname, node_type)
                        # cleanup(cve_node_id, registry_type, image_file_folder)
                        # return
                        break
            # In case of es failure, cve_status is empty, exit if waiting for >120 min
            if (curr_dt - start_time) > timedelta(minutes=120):
                add_scan_log("Image upload failed - no status available",
                             CVE_SCAN_STATUS_WARN, hostname, node_type)
                # add_scan_log("Image upload failed - no status available", CVE_SCAN_STATUS_ERROR, hostname, node_type)
                # cleanup(cve_node_id, registry_type, image_file_folder)
                # return
                break
            time.sleep(20)
        docker_args = "-scan-type='{0}' -image-name='{1}' -image-path='{2}' -image-id='{3}' -container-name='{4}' -host-name='{5}' -scan-id='{6}' -update-dependency-data='{7}' -mgmt-console-url='{8}' -deepfence-key='{9}' -is-image-local='false' -kubernetes-cluster-name='{10}' -mask-cve-ids='{11}'".format(
            scan_type, image_or_host, image_file_path, node.image_id, node.container_name, hostname, scan_id,
            update_dependency_data, mgmt_console_url, deepfence_key, kubernetes_cluster_name, mask_cve_ids)

    """
    Launch deepaudit
    """
    if orchestrator == docker_orchestrator:
        user_namespace_mode = ""
        try:
            docker_client = docker.from_env()
            celery_containers = docker_client.containers.list(
                filters={"name": "deepfence-celery"})
            for celery_container in celery_containers:
                if celery_container.attrs.get("Name", "") == "/deepfence-celery" or celery_container.attrs.get(
                        "Config", {}).get("Labels", {}).get("io.kubernetes.container.name") == "deepfence-celery":
                    user_namespace_mode = celery_container.attrs.get(
                        "HostConfig", {}).get("UsernsMode", "")
                    break
        except:
            pass
        cmd_line = "docker run --rm --net=host --privileged=true --ulimit core=0 --cpus='0.2' -e GODEBUG=x509ignoreCN=0"
        if user_namespace_mode:
            cmd_line += " --userns=" + user_namespace_mode
        for k, v in docker_volumes.items():
            cmd_line += " -v {0}:{1}:{2}".format(k, v["bind"], v["mode"])
        cmd_line += " --entrypoint=" + docker_entrypoint + \
                    " " + mapper_image_name_with_tag + " " + docker_args
        pidVal = Popen(cmd_line, stdin=PIPE, stdout=PIPE, shell=True)
        std_out, std_err = pidVal.communicate()
        if std_err:
            print(std_err)

        fname = log_file_name
        if fname == "host":
            fname = node.host_name
        std_out_string = str(std_out, 'utf-8')
        store_vulnerability_log(fname, std_out_string)

        # retry_count = 0
        # while retry_count < 3:
        #     try:
        #         docker_client.containers.run(
        #             mapper_image_name_with_tag, network_mode="host", volumes=docker_volumes, detach=False, remove=True,
        #             stderr=True, stdout=True, privileged=True, cpu_quota=20000, cpu_period=100000,
        #             entrypoint=[docker_entrypoint], command=docker_args, auto_remove=True)
        #         # mapper.wait(timeout=3600)
        #         # mapper.remove()
        #         break
        #     except Exception as ex:
        #         print(ex)
        #         # add_scan_log("Error: " + str(ex), CVE_SCAN_STATUS_ERROR, hostname, node_type)
        #     retry_count += 1
        #     time.sleep(20)
    elif orchestrator == k8s_orchestrator:
        sanitized_scan_id = "vulnerability-" + \
                            md5_hash(scan_id).replace("=", "")
        sanitized_scan_id = sanitized_scan_id[:60]
        try:
            volume_types = {"/tmp": ""}
            volume_names = {"/tmp": "tmp"}
            if os.path.exists("/var/run/docker.sock"):
                volume_types.update({
                    "/var/run/docker.sock": "Socket",
                    "/etc/docker/certs.d": ""
                })
                volume_names.update({
                    "/var/run/docker.sock": "docker-sock",
                    "/etc/docker/certs.d": "docker-certs"
                })
            if os.path.exists("/run/containerd/containerd.sock"):
                volume_types.update({
                    "/run/containerd/containerd.sock": "Socket",
                    "/var/lib/containerd": "",
                    "/etc/containerd/certs.d": ""
                })
                volume_names.update({
                    "/run/containerd/containerd.sock": "containerd-sock",
                    "/var/lib/containerd": "containerd-lib",
                    "/etc/containerd/certs.d": "containerd-certs"
                })
            if os.path.exists("/run/k3s/containerd/containerd.sock"):
                volume_types.update({
                    "/run/k3s/containerd/containerd.sock": "Socket",
                    "/var/lib/containerd": "",
                    "/etc/containerd/certs.d": ""
                })
                volume_names.update({
                    "/run/k3s/containerd/containerd.sock": "containerd-sock",
                    "/var/lib/containerd": "containerd-lib",
                    "/etc/containerd/certs.d": "containerd-certs"
                })
            k8s_labels = {
                "app": "deepfence-vulnerability-mapper",
                "scan-id": sanitized_scan_id
            }
            docker_args_arr = []
            for arg in docker_args.split(" "):
                tmp_arg = arg
                if tmp_arg.startswith("'"):
                    tmp_arg = tmp_arg[1:]
                if tmp_arg.endswith("'"):
                    tmp_arg = tmp_arg[:-1]
                tmp_arg = tmp_arg.replace("='", "=")
                docker_args_arr.append(tmp_arg)
            volume_mounts = [k8s_client.V1VolumeMount(
                mount_path="/data", read_only=False, name="data")]
            volumes = [k8s_client.V1Volume(
                name="data", empty_dir=k8s_client.V1EmptyDirVolumeSource())]
            for k, v in docker_volumes.items():
                if not volume_names.get(k, ""):
                    continue
                volume_mounts.append(
                    k8s_client.V1VolumeMount(
                        mount_path=v["bind"],
                        read_only=False if v["mode"] == "rw" else True,
                        name=volume_names[k],
                    )
                )
                volumes.append(
                    k8s_client.V1Volume(
                        name=volume_names[k],
                        host_path=k8s_client.V1HostPathVolumeSource(
                            path=k, type=volume_types[k]
                        )
                    )
                )
            image_pull_secrets = None
            if k8s_image_pull_secret_name:
                image_pull_secrets = [k8s_client.V1LocalObjectReference(name=k8s_image_pull_secret_name)]
            job = k8s_client.V1Job(
                api_version="batch/v1",
                kind="Job",
                metadata=k8s_client.V1ObjectMeta(
                    namespace=k8s_namespace,
                    name=sanitized_scan_id,
                    labels=k8s_labels
                ),
                spec=k8s_client.V1JobSpec(
                    template=k8s_client.V1PodTemplateSpec(
                        metadata=k8s_client.V1ObjectMeta(
                            labels=k8s_labels
                        ),
                        spec=k8s_client.V1PodSpec(
                            restart_policy="Never",
                            volumes=volumes,
                            image_pull_secrets=image_pull_secrets,
                            containers=[
                                k8s_client.V1Container(
                                    name=sanitized_scan_id,
                                    env=[k8s_client.V1EnvVar(name="GODEBUG", value="x509ignoreCN=0")],
                                    image=mapper_image_name_with_tag,
                                    args=docker_args_arr,
                                    command=[docker_entrypoint],
                                    image_pull_policy="Always",
                                    volume_mounts=volume_mounts,
                                    security_context=k8s_client.V1SecurityContext(privileged=True),
                                    resources=k8s_client.V1ResourceRequirements(
                                        limits={"cpu": "200m"},
                                        requests={"cpu": "200m",
                                                  "memory": "200Mi"}
                                    )
                                )
                            ]
                        )
                    ),
                    backoff_limit=0),
                status=k8s_client.V1JobStatus()
            )
            batchV1 = k8s_client.BatchV1Api()
            batchV1.create_namespaced_job(
                namespace=k8s_namespace, body=job, _request_timeout=300)
            # Wait till the job completes / fails
            while True:
                try:
                    time.sleep(30)
                    cve_job = batchV1.read_namespaced_job(name=sanitized_scan_id, namespace=k8s_namespace,
                                                          _request_timeout=300)
                    if cve_job.status.completion_time:
                        break
                    if cve_job.status.failed:
                        add_scan_log("Error: vulnerability mapper job failed", CVE_SCAN_STATUS_ERROR, hostname,
                                     node_type)
                        break
                except Exception as ex:
                    add_scan_log("Error: " + str(ex),
                                 CVE_SCAN_STATUS_ERROR, hostname, node_type)
                    break
            # Get logs from job
            try:
                cve_job = batchV1.read_namespaced_job(name=sanitized_scan_id, namespace=k8s_namespace,
                                                      _request_timeout=300)
                v1 = k8s_client.CoreV1Api()
                pods = v1.list_namespaced_pod(
                    namespace=k8s_namespace,
                    label_selector="controller-uid={0},job-name={1}".format(cve_job.metadata.uid, sanitized_scan_id))
                for pod in pods.items:
                    try:
                        pod_log = v1.read_namespaced_pod_log(
                            name=pod.metadata.name, namespace=k8s_namespace)
                        store_vulnerability_log(cve_node_id, pod_log)
                        break
                    except Exception as ex:
                        break
            except Exception as ex:
                pass
            # Delete job pod
            retry_count = 0
            while retry_count < 3:
                try:
                    batchV1.delete_namespaced_job(name=sanitized_scan_id, namespace=k8s_namespace,
                                                  propagation_policy="Foreground", _request_timeout=300)
                    break
                except Exception as ex:
                    print(ex)
                retry_count += 1
                time.sleep(20)

        except Exception as ex:
            add_scan_log("Error: " + str(ex),
                         CVE_SCAN_STATUS_ERROR, hostname, node_type)

    cleanup(cve_node_id, registry_type, image_file_folder)
