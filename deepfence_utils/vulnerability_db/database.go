package vulnerability_db

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path"
	"sort"
	"time"

	"github.com/deepfence/ThreatMapper/deepfence_utils/directory"
	"github.com/deepfence/ThreatMapper/deepfence_utils/log"
	"github.com/deepfence/ThreatMapper/deepfence_utils/utils"
	"github.com/minio/minio-go/v7"
)

const (
	Version3 = "3"
	Version5 = "5"
)

var (
	ListingJson                = "listing.json"
	VulnerabilityDbStore       = "vulnerability"
	ListingPath                = path.Join(VulnerabilityDbStore, ListingJson)
	DEEPFENCE_THREAT_INTEL_URL = "https://threat-intel.deepfence.io/vulnerability-db/listing.json"
)

type DBUploadRequest struct {
	Database multipart.File `formData:"database" json:"database" validate:"required" required:"true"`
}

type VulnerabilityDBListing struct {
	Available map[string][]Database `json:"available"`
}

type Database struct {
	Built    time.Time `json:"built"`
	Version  int       `json:"version"`
	URL      string    `json:"url"`
	Checksum string    `json:"checksum"`
}

func NewVulnerabilityDBListing() *VulnerabilityDBListing {
	return &VulnerabilityDBListing{
		Available: map[string][]Database{
			Version3: make([]Database, 0),
			Version5: make([]Database, 0),
		},
	}
}

func LoadListing(d []byte) (*VulnerabilityDBListing, error) {
	var v VulnerabilityDBListing
	if err := json.Unmarshal(d, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (v *VulnerabilityDBListing) Bytes() ([]byte, error) {
	return json.Marshal(v)
}

func (v *VulnerabilityDBListing) Append(db Database, version string) {
	v.Available[version] = append(v.Available[version], db)
}

func (v *VulnerabilityDBListing) Sort(version string) {
	if len(v.Available[version]) <= 1 {
		return
	}

	dbs := v.Available[version]
	sort.Slice(dbs[:], func(i, j int) bool {
		return dbs[i].Built.Before(dbs[j].Built)
	})
	v.Available[version] = dbs
}

func (v *VulnerabilityDBListing) Latest(version string) *Database {
	// sort, get last element
	v.Sort(version)

	dbs, ok := v.Available[version]
	if !ok {
		return nil

	}
	if len(dbs) >= 1 {
		return &dbs[len(dbs)-1]
	}
	return nil
}

func UploadToMinio(ctx context.Context, fb []byte, fName string) (string, string, error) {

	mc, err := directory.MinioClient(directory.WithDatabaseContext(ctx))
	if err != nil {
		return "", "", err
	}

	dbFile := path.Join(VulnerabilityDbStore, fName)
	info, err := mc.UploadFile(directory.WithDatabaseContext(ctx), dbFile, fb, true, minio.PutObjectOptions{})
	if err != nil {
		return "", "", err
	}

	return info.Key, utils.SHA256sum(fb), nil
}

func UpdateListing(newFile, newFileCheckSum string, buildTime time.Time) {
	log.Info().Msg("update vulnerability database listing")

	ctx := context.Background()
	mc, err := directory.MinioClient(directory.WithDatabaseContext(ctx))
	if err != nil {
		log.Error().Msg(err.Error())
		return
	}

	data, err := mc.DownloadFileContexts(ctx, ListingPath, minio.GetObjectOptions{})
	if err != nil {
		log.Error().Err(err).Msg("failed to load listing file")
	}

	listing, err := LoadListing(data)
	if err != nil {
		listing = NewVulnerabilityDBListing()
	}

	minioHost := utils.GetEnvOrDefault("DEEPFENCE_MINIO_HOST", "deepfence-file-server")
	minioPort := utils.GetEnvOrDefault("DEEPFENCE_MINIO_PORT", "9000")
	minioRegion := os.Getenv("DEEPFENCE_MINIO_REGION")
	minioBucket := os.Getenv("DEEPFENCE_MINIO_DB_BUCKET")

	// for aws s3
	fileURL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s", minioBucket, minioRegion, newFile)
	if minioHost != "s3.amazonaws.com" {
		fileURL = fmt.Sprintf("http://%s:%s/%s",
			minioHost, minioPort, path.Join(string(directory.DatabaseDirKey), newFile))
	}

	listing.Append(
		Database{
			Built:    buildTime,
			Version:  5,
			URL:      fileURL,
			Checksum: newFileCheckSum,
		},
		Version5,
	)

	lb, err := listing.Bytes()
	if err != nil {
		log.Error().Msgf(err.Error())
		return
	}

	_, err = mc.UploadFile(ctx, ListingPath, lb, true, minio.PutObjectOptions{ContentType: "application/json"})
	if err != nil {
		log.Error().Msgf(err.Error())
		return
	}

	log.Info().Msgf("vulnerability db listing updated with file %s checksum %s",
		newFile, newFileCheckSum)

}

func DownloadDatabase() {

	log.Info().Msg("download latest vulnerability database")

	df_listing_url := utils.GetEnvOrDefault(
		"DEEPFENCE_THREAT_INTEL_URL",
		DEEPFENCE_THREAT_INTEL_URL,
	)

	client := http.Client{Timeout: 60 * time.Second}

	resp, err := client.Get(df_listing_url)
	if err != nil {
		log.Error().Msgf(err.Error())
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Error().Msgf("listing url response: %s", resp.Status)
		return
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Error().Msgf(err.Error())
		return
	}

	var listing VulnerabilityDBListing
	if err := json.Unmarshal(body, &listing); err != nil {
		log.Error().Msgf(err.Error())
		return
	}

	log.Info().Msgf("available vulnerability databases V3=%d V5=%d",
		len(listing.Available[Version3]), len(listing.Available[Version5]))

	// sort by built time
	// listing.Sort(model.Version5)

	latest := listing.Latest(Version5)
	if latest == nil {
		log.Error().Msgf("latest v5 database are empty, check listing url")
		return
	}

	log.Info().Msgf("latest threat intel db: %v", latest)

	data, err := downloadFile(latest.URL)
	if err != nil {
		log.Error().Msgf(err.Error())
		return
	}

	path, _, err := UploadToMinio(context.Background(), data.Bytes(), path.Base(latest.URL))
	if err != nil {
		log.Error().Msg(err.Error())
		return
	}

	// update listing.json file
	UpdateListing(path, latest.Checksum, latest.Built)

}

func downloadFile(url string) (*bytes.Buffer, error) {

	client := http.Client{Timeout: 600 * time.Second}

	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("bad status: %s", resp.Status)
	}

	var out bytes.Buffer
	_, err = io.Copy(bufio.NewWriter(&out), resp.Body)
	if err != nil {
		return nil, err
	}

	return &out, nil
}
