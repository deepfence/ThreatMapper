package vulnerability_scan_service

import (
	"bytes"
	"fmt"
	"net/http"
	"os"

	"github.com/deepfence/package-scanner/output"
	"github.com/deepfence/package-scanner/util"
	"github.com/deepfence/vulnerability_mapper/scanner/grype"
	"github.com/deepfence/vulnerability_mapper/utils"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
)

var (
	cveEsIndex = "cve"
	IngestAPI  = fmt.Sprintf("http://deepfence-fetcher:8006/df-api/ingest?doc_type=%s", cveEsIndex)
)

func New() *VulnerabilityScanService {
	return &VulnerabilityScanService{}
}

// Scan is a handler function for the /vulnerability-scan endpoint
// It takes a sbom and returns a json document containing the cve information
// e.g.
//	curl --location --request POST 'http://127.0.0.1:8085/vulnerability-mapper-api/vulnerability-scan?image-name=dum-im&image-id=abc1234&scan-id=xyz456' \
//	--header 'Content-Type: application/json' \
//	--data-raw '/*sbom json*/'
func (c *VulnerabilityScanService) Scan(gc *gin.Context) {
	// userInput is a vulnerability sbom in json format
	sbom, err := gc.GetRawData()
	if err != nil {
		log.Errorf("Invalid post data: %s", err.Error())
		gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	nodeId := gc.Query("node_id")
	maskCveIds := gc.Query("mask_cve_ids")

	// validate sbom and return error if invalid
	//if err := utils.ValidateSbom(sbom); err != nil {
	//	gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	log.Errorf("Invalid sbom: %s", err.Error())
	//	return
	//}

	scannerConfig := util.Config{
		ManagementConsoleUrl:  "deepfence-internal-router",
		ManagementConsolePort: "443",
		ScanType:              gc.Query("scan_type"),
		ScanId:                gc.Query("scan_id"),
		NodeType:              gc.Query("node_type"),
		NodeId:                nodeId,
		HostName:              gc.Query("host_name"),
		ImageId:               gc.Query("image_id"),
		ContainerName:         gc.Query("container_name"),
		KubernetesClusterName: gc.Query("kubernetes_cluster_name"),
		MaskCveIds:            maskCveIds,
	}

	// start a go routine here
	go func() {
		publisher, err := output.NewPublisher(scannerConfig)
		if err != nil {
			return
		}
		publisher.PublishScanStatus("SCAN_IN_PROGRESS")

		go func() {
			esErr := publisher.PublishSBOMtoES(sbom)
			if esErr != nil {
				log.Errorf("error in publishing sbom to es:" + esErr.Error())
			}
		}()

		// create a temporary file to store the user input(SBOM)
		file, err := utils.CreateTempFile(sbom)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf(err.Error())
			return
		}

		defer os.Remove(file.Name())

		vulnerabilities, err := grype.Scan(file.Name())
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf(err.Error())
			return
		}

		report, err := grype.PopulateFinalReport(vulnerabilities, scannerConfig)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf(err.Error())
			return
		}

		s := fmt.Sprintf("[%s]", utils.TrimSuffix(report, ","))
		err = publisher.PublishDocument(IngestAPI, bytes.NewReader([]byte(s)))
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf(err.Error())
			return
		}

		publisher.StopPublishScanStatus()
		publisher.PublishScanStatusMessage("", "COMPLETED")
		log.Infof("Scan completed for image: %s", nodeId)
	}()
	gc.JSON(http.StatusOK, gin.H{"status": "scan started"})
}
