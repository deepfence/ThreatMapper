package vulnerability_scan_service

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/deepfence/vulnerability_mapper/scanner"

	"github.com/deepfence/package-scanner/output"
	"github.com/deepfence/package-scanner/util"
	"github.com/deepfence/vulnerability_mapper/scanner/grype"
	"github.com/deepfence/vulnerability_mapper/utils"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
)

var (
	cveEsIndex = "cve"
	IngestAPI  = fmt.Sprintf("https://deepfence-internal-router:443/ingest/topics/%s", cveEsIndex)
	// IngestAPI = fmt.Sprintf("http://deepfence-rest-proxy:8082/topics/%s", cveEsIndex)
)

func New() *VulnerabilityScanService {
	return &VulnerabilityScanService{}
}

// Scan is a handler function for the /vulnerability-scan endpoint
// It takes a sbom and returns a json document containing the cve information
// e.g.
//
//	curl --location --request POST 'http://127.0.0.1:8085/vulnerability-mapper-api/vulnerability-scan?image-name=dum-im&image-id=abc1234&scan-id=xyz456' \
//	--header 'Content-Type: application/json' \
//	--data-raw '/*sbom json*/'
func (c *VulnerabilityScanService) Scan(gc *gin.Context) {
	// userInput is a vulnerability sbom in json format
	sbom, err := gc.GetRawData()
	if err != nil {
		log.Errorf("Invalid post data: %s", err.Error())
		gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	nodeId := gc.Query("node_id")
	maskCveIds := gc.Query("mask_cve_ids")

	// validate sbom and return error if invalid
	//if err := utils.ValidateSbom(sbom); err != nil {
	//	gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	//	log.Errorf("Invalid sbom: %s", err.Error())
	//	return
	//}

	scannerConfig := util.Config{
		ManagementConsoleUrl:  "deepfence-internal-router",
		ManagementConsolePort: "443",
		ScanType:              gc.Query("scan_type"),
		ScanId:                gc.Query("scan_id"),
		NodeType:              gc.Query("node_type"),
		NodeId:                nodeId,
		HostName:              gc.Query("host_name"),
		ImageId:               gc.Query("image_id"),
		ContainerName:         gc.Query("container_name"),
		KubernetesClusterName: gc.Query("kubernetes_cluster_name"),
		MaskCveIds:            maskCveIds,
		ImageName:             gc.Query("image_name"),
		RegistryId:            gc.Query("registry_id"),
	}

	log.Infof("config %+v", scannerConfig)

	// start a go routine here
	go func(config util.Config) {
		log.Infof("config %+v", config)
		publisher, err := output.NewPublisher(config)
		if err != nil {
			return
		}
		publisher.PublishScanStatus("SCAN_IN_PROGRESS")

		go func() {
			esErr := publisher.PublishSBOMtoES(sbom)
			if esErr != nil {
				log.Errorf("error in publishing sbom to es: %s", esErr.Error())
			}
		}()

		// create a temporary file to store the user input(SBOM)
		file, err := utils.CreateTempFile(sbom)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf("error on CreateTempFile: %s", err.Error())
			return
		}

		defer os.Remove(file.Name())

		log.Infof("temporary file name: %s", file.Name())

		vulnerabilities, err := grype.Scan(file.Name())
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf("error on grype.Scan: %s", err.Error())
			return
		}

		report, err := grype.PopulateFinalReport(vulnerabilities, config)
		if err != nil {
			publisher.PublishScanError(err.Error())
			log.Errorf("error on PopulateFinalReport: %s", err.Error())
			return
		}

		// s := fmt.Sprintf("[%s]", utils.TrimSuffix(report, ","))
		if len(report) > 0 {
			finalReportInByte := format(report)
			err = publisher.PublishDocument(IngestAPI, bytes.NewReader(finalReportInByte))
			if err != nil {
				publisher.PublishScanError(err.Error())
				log.Errorf("error on PublishDocument: %s", err.Error())
				return
			}
		}

		publisher.StopPublishScanStatus()
		publisher.PublishScanStatusMessage("", "COMPLETED")
		log.Infof("Scan completed for image: %s", nodeId)
	}(scannerConfig)
	gc.JSON(http.StatusOK, gin.H{"status": "scan started"})
}

// data needs to be in this format
// {"records":[{"value":<record1>},{"value":record2}]}
func format(data []scanner.VulnerabilityScanReport) []byte {
	values := make([]string, len(data))
	for i, u := range data {
		encoded, err := json.Marshal(&u)
		if err != nil {
			log.Errorf("failed to Marshal cve error: %s", err)
			log.Errorf("failed to Marshal cve report: %s", u)
			continue
		}
		values[i] = "{\"value\":" + string(encoded) + "}"
	}
	result := strings.Join(values, ",")
	return []byte("{\"records\":[" + result + "]}")
}
