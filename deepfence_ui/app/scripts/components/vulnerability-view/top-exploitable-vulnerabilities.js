/* eslint-disable react/destructuring-assignment */
/*eslint-disable*/
import React, { useEffect, useRef } from 'react';
import { connect, useDispatch } from 'react-redux';
import {
  getTopVulnerableActiveContainersAction,
  getTopVulnerableAttackPathsAction,
  updateTableJSONModalView,
  toaster
} from '../../actions/app-actions';
import pollable from '../common/header-view/pollable';
import { DfTableV2 } from '../common/df-table-v2';
import { fetchAlertsData } from '../../utils/web-api-utils';
import TopExploitableSeverityReport from './top-exploitable-severity-report';
import { DagreGraph, formatApiDataForDagreGraph } from '../common/dagre-graph';


const TopExploitableVulnerabilities = props => {

  const oldProps = useRef(props);
  const dispatch = useDispatch();

  useEffect(() => {
    // pollable: register the function which needs to be polled
    const {
      registerPolling,
      startPolling,
    } = props;
    registerPolling((params) => getTopStats(params));
    startPolling();
  }, [])

  useEffect(() => {
    const {
      alertPanelHistoryBound: newBounds,
      globalSearchQuery: newQuery,
    } = props;
    const {
      alertPanelHistoryBound: currentBounds,
      globalSearchQuery: currentQuery,
    } = oldProps.current;

    if (currentBounds !== newBounds || currentQuery !== newQuery) {
      getTopStats({
        alertPanelHistoryBound: newBounds,
        globalSearchQuery: newQuery,
      });
    }
    oldProps.current = props;
  }, [props])

  const getTopStats = (params = {}) => {
    const {
      alertPanelHistoryBound = props.alertPanelHistoryBound || [],
      globalSearchQuery = props.globalSearchQuery || [],
    } = params;

    const {
      getTopVulnerableActiveContainersAction,
      getTopVulnerableAttackPathsAction
    } = props;

    const apiParams = {
      luceneQuery: globalSearchQuery,
      ...(alertPanelHistoryBound.value
        ? { number: alertPanelHistoryBound.value.number } : {}),
      ...(alertPanelHistoryBound.value
        ? { timeUnit: alertPanelHistoryBound.value.time_unit } : {}),
    };

    return Promise.all([getTopVulnerableActiveContainersAction(apiParams), getTopVulnerableAttackPathsAction(apiParams)]);
  }


  const handleCVEIdClick = (alertDocId) => {
    const { alertIndex = {} } = props;

    if (!alertIndex[alertDocId]) {
      const params = {
        activeIndex: 0,
        recordsPerPage: 1,
        sortOrder: 'desc',
        activeFilter: {
          doc_id: alertDocId,
        },
        lucene_query: [],
        type: 'cve',
      };
      fetchAlertsData(dispatch, params).then((response) => {
        const alertList = response.data.hits;
        if (alertList.length === 1) {
          dispatch(updateTableJSONModalView(alertList[0]));
        } else {
          dispatch(toaster('The requested alert either masked or not found'));
        }
      });
    } else {
      dispatch(updateTableJSONModalView(alertIndex[alertDocId]));
    }
  }

    const {
      topStats = [],
      groupedTopExploits = [],
      globalSearchQuery,
      // dispatch,
      topAttackPaths
    } = props;
    let allEmpty = false;
    if (groupedTopExploits && groupedTopExploits.children) {
      if (
        groupedTopExploits.children[0].children.length === 0
        && groupedTopExploits.children[1].children.length === 0
        && groupedTopExploits.children[2].children.length === 0
        && groupedTopExploits.children[3].children.length === 0
      ) {
        allEmpty = true;
      }
    }
    const emptyData = allEmpty;


    return (
      <div className="runtime-vulnerabilities">
        <div className="runtime-vulnerabilities-chart">
          <div className="charts-heading">Most exploitable vulnerabilities and Top attack paths</div>
          <div className="charts-container">
            <div className="chart-container">
              {emptyData
                ? (
                  <div className="empty-data">
                    Vulnerabilities data not available
                  </div>
                ) : <TopExploitableSeverityReport
                  data={groupedTopExploits}
                  globalSearchQuery={globalSearchQuery}
                  // dispatch={dispatch}
                />}
            </div>
            <div className="chart-container dagre-chart-container">
              {
                topAttackPaths && Array.isArray(topAttackPaths) && topAttackPaths.length ? (
                  <DagreGraph
                    data={formatApiDataForDagreGraph(topAttackPaths)}
                    width={400}
                    height={500}
                  />
                ) : (
                  <div className="empty-data">
                    Attack path data not available.
                  </div>
                )
              }
            </div>
          </div>
        </div>
        <div className="runtime-vulnerabilities-chart">
          <DfTableV2
            onRowClick={(row) => handleCVEIdClick(row.original.docId)}
            enableSorting
            data={topStats}
            showPagination
            columns={[
              {
                Header: 'Rank',
                accessor: 'rank',
                width: 50,
                sortType: 'number'
              },
              {
                Header: 'CVE ID',
                accessor: 'cveId',
                width: 100,
                Cell: row => (
                  <div
                    className="truncate"
                    title={row.value}>
                    {row.value}
                  </div>
                ),
              },
              {
                Header: 'Severity',
                accessor: 'cveSeverity',
                width: 100,
                minWidth: 100,
                Cell: row => (
                  <div
                    className={`${row.value}-severity`}
                  >
                    {row.value}
                  </div>
                ),
              },
              {
                Header: 'Score',
                accessor: 'score',
                width: 50,
                Cell: row => (
                  <div>
                    {row.value.toFixed(2)}
                  </div>
                ),
                sortType: 'number'
              },
              {
                Header: 'Attack Vector',
                accessor: 'attackVector',
                width: 120,
              },
              {
                Header: 'Image',
                id: 'image',
                accessor: (row) => {
                  const {
                    vulnerableImages = [],
                    image,
                  } = row;
                  const otherImages = vulnerableImages.length - 1;
                  return `${image} ${otherImages ? ` + ${otherImages} image(s)` : ''}`;
                },
                Cell: (row) => {
                  const {
                    original: {
                      vulnerableImages = [],
                    } = {},
                  } = row;
                  const otherImages = vulnerableImages.join(', ');
                  return (
                    <div
                      className="truncate"
                      title={otherImages}>
                      {row.value}
                    </div>
                  );
                },
                width: 200,
              },
              {
                Header: 'Description',
                accessor: 'description',
                Cell: row => (
                  <div
                    className="truncate"
                    title={row.value}>
                    {row.value}
                  </div>
                ),
                width: 300,
              },
            ]} />
        </div>
      </div>
    );
}
const mapStateToProps = (state) => ({
  alertPanelHistoryBound: state.get('alertPanelHistoryBound') || [],
  globalSearchQuery: state.get('globalSearchQuery') || [],
  topStats: state.getIn(['cve', 'top_exploits']) || [],
  groupedTopExploits: state.getIn(['cve', 'top_exploits_grouped']),
  topAttackPaths: state.getIn(['topAttackPaths', 'data'])
});

export default connect(
  mapStateToProps, {
  getTopVulnerableActiveContainersAction,
  getTopVulnerableAttackPathsAction
}
)(pollable()(TopExploitableVulnerabilities));
