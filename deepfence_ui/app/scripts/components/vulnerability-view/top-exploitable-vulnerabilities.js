/* eslint-disable */
import React from 'react';
import { connect } from 'react-redux';
import { Map } from 'immutable';
import {
  getTopVulnerableActiveContainersAction,
  getAttackPathsAction,
  toaster,
  downloadMostExploitableAction,
} from '../../actions/app-actions';
import pollable from '../common/header-view/pollable';
import { DfTableV2 } from '../common/df-table-v2';
import { fetchAlertsData } from '../../utils/web-api-utils';
import TopExploitableSeverityReport from './top-exploitable-severity-report';
import { DagreGraph, formatApiDataForDagreGraph } from '../common/dagre-graph';
import { VulnerabilityModal } from './vulnerability-modal';
import { GraphTypeSelector } from '../common/dagre-graph/graph-type-selector';
import AppLoader from "../common/app-loader/app-loader";

const graphOptions = [{
  label: 'Most vulnerable attack paths',
  value: 'most_vulnerable_attack_paths'
}, {
  label: 'Paths with direct internet exposure',
  value: 'direct_internet_exposure'
}, {
  label: 'Paths with indirect internet exposure',
  value: 'indirect_internet_exposure'
}];

class TopExploitableVulnerabilities extends React.Component {
  constructor(props) {
    super(props);
    this.handleCVEIdClick = this.handleCVEIdClick.bind(this);
    this.downloadClick = this.downloadClick.bind(this);
    this.getTopStats = this.getTopStats.bind(this);
    this.state = {
      isVulnerabilityModalOpen: false,
      cveData: null,
      graphType: graphOptions[0].value
    }
    this.tableRef = React.createRef();
  }

  componentDidMount() {
    // pollable: register the function which needs to be polled
    const {
      registerPolling,
      startPolling,
    } = this.props;
    registerPolling(this.getTopStats);
    startPolling();
  }

  UNSAFE_componentWillReceiveProps(newProps) {
    const {
      alertPanelHistoryBound: newBounds,
      globalSearchQuery: newQuery,
    } = newProps;
    const {
      alertPanelHistoryBound: currentBounds,
      globalSearchQuery: currentQuery,
    } = this.props;

    if (currentBounds !== newBounds || currentQuery !== newQuery) {
      this.tableRef?.current?.resetPageIndex?.(0);
      this.getTopStats({
        alertPanelHistoryBound: newBounds,
        globalSearchQuery: newQuery,
      });
    }
  }

  getTopStats(params = {}) {
    const {
      alertPanelHistoryBound = this.props.alertPanelHistoryBound || [],
      globalSearchQuery = this.props.globalSearchQuery || [],
    } = params;

    const {
      getTopVulnerableActiveContainersAction,
      getAttackPathsAction
    } = this.props;

    const apiParams = {
      luceneQuery: globalSearchQuery,
      ...(alertPanelHistoryBound.value
        ? { number: alertPanelHistoryBound.value.number } : {}),
      ...(alertPanelHistoryBound.value
        ? { timeUnit: alertPanelHistoryBound.value.time_unit } : {}),
    };
    return Promise.all([getTopVulnerableActiveContainersAction(apiParams), getAttackPathsAction({
      ...apiParams,
      graphType: this.state.graphType
    })]);
  }

  handleCVEIdClick(alertDocId) {
    const { alertIndex = {}, dispatch } = this.props;

    if (!alertIndex[alertDocId]) {
      const params = {
        activeIndex: 0,
        recordsPerPage: 1,
        sortOrder: 'desc',
        activeFilter: {
          doc_id: alertDocId,
        },
        lucene_query: [],
        type: 'cve',
      };
      fetchAlertsData(dispatch, params).then((response) => {
        const alertList = response.data.hits;
        if (alertList.length === 1) {
          this.setState({
            isVulnerabilityModalOpen: true,
            cveData: alertList[0]
          });
        } else {
          dispatch(toaster('The requested CVE not found'));
        }
      });
    } else {
      this.setState({
        isVulnerabilityModalOpen: true,
        cveData: alertIndex[alertDocId]
      });
    }
  }

  downloadClick() {
    const { dispatch } = this.props;
    dispatch(downloadMostExploitableAction());
  }

  render() {
    const {
      topStats = [],
      groupedTopExploits = [],
      globalSearchQuery,
      dispatch,
      attackPaths: attackPathsIndex = Map(),
      attackPathsLoading: attackPathsLoadingIndex = Map(),
    } = this.props;
    const attackPaths = attackPathsIndex.get(this.state.graphType, []);
    const attackPathsLoading = attackPathsLoadingIndex.get(this.state.graphType, false);
    let allEmpty = false;
    if (groupedTopExploits && groupedTopExploits.children) {
      if (
        groupedTopExploits.children[0].children.length === 0
        && groupedTopExploits.children[1].children.length === 0
        && groupedTopExploits.children[2].children.length === 0
        && groupedTopExploits.children[3].children.length === 0
      ) {
        allEmpty = true;
      }
    }
    const emptyData = allEmpty;


    return (
      <div className="runtime-vulnerabilities">
        <button className="download primary-btn" onClick={this.downloadClick}>
          Download Report
        </button>
        <div className="runtime-vulnerabilities-chart">
          <div className="charts-heading">Most exploitable vulnerabilities and Top attack paths</div>
          <div className="charts-container">
            <div className="chart-container">
              {emptyData
                ? (
                  <div className="empty-data">
                    Vulnerabilities data not available
                  </div>
                ) : <TopExploitableSeverityReport
                  data={groupedTopExploits}
                  globalSearchQuery={globalSearchQuery}
                  dispatch={dispatch}
                />}
            </div>
            <div className="chart-container dagre-chart-container">
              {
                attackPaths && Array.isArray(attackPaths) && attackPaths.length ? (
                  <DagreGraph
                    data={formatApiDataForDagreGraph(attackPaths)}
                  />
                ) : attackPathsLoading ? (
                  <AppLoader />
                ) : (
                  <div className="empty-data">
                    No attack paths exist
                  </div>
                )
              }
            </div>
            <div className="chart-container">
              <GraphTypeSelector onChange={(graphType) => {
                this.setState({
                  graphType
                }, () => {
                  this.getTopStats();
                });
              }}
                graphOptions={graphOptions}
              />
            </div>
          </div>
        </div>
        <div className="runtime-vulnerabilities-chart">
          <DfTableV2
            ref={this.tableRef}
            onRowClick={(row) => this.handleCVEIdClick(row.original.docId)}
            enableSorting
            data={topStats}
            showPagination
            columns={[
              {
                Header: 'Rank',
                accessor: 'rank',
                width: 50,
                sortType: 'number'
              },
              {
                Header: 'CVE ID',
                accessor: 'cveId',
                width: 100,
                Cell: row => (
                  <div
                    className="truncate"
                    title={row.value}>
                    {row.value}
                  </div>
                ),
              },
              {
                Header: 'Severity',
                accessor: 'cveSeverity',
                width: 100,
                minWidth: 100,
                Cell: row => (
                  <div
                    className={`${row.value}-severity`}
                  >
                    {row.value}
                  </div>
                ),
              },
              {
                Header: 'Score',
                accessor: 'score',
                width: 50,
                Cell: row => (
                  <div>
                    {row.value.toFixed(2)}
                  </div>
                ),
                sortType: 'number'
              },
              {
                Header: 'Attack Vector',
                accessor: 'attackVector',
                width: 80,
              },
              {
                Header: 'Live Connection',
                accessor: 'liveConnection',
                width: 80,
                Cell: (row) => (
                  <div style={{ display: 'flex', alignItems: 'center' }}>
                    <div>{row.value ? 'Yes' : 'No'}</div>
                  </div>
                ),
              },
              {
                Header: 'Exploit',
                accessor: 'exploitPoc',
                width: 60,
                Cell: (row) =>{
                  return (
                    <div style={{ display: 'flex', alignItems: 'center' }}>
                      {
                        row.value && row.value.length ? (
                          <a href={row.value} onClick={(e) => e.stopPropagation()} target="_blank" rel="noreferrer">Link &nbsp;<i className='fa fa-external-link-square' /></a>
                        ) : <div>-</div>
                      }
                    </div>
                  )
                },
              },
              {
                Header: 'Image',
                id: 'image',
                accessor: (row) => {
                  const {
                    vulnerableImages = [],
                    image,
                  } = row;
                  const otherImages = vulnerableImages.length - 1;
                  return `${image} ${otherImages ? ` + ${otherImages} image(s)` : ''}`;
                },
                Cell: (row) => {
                  const {
                    original: {
                      vulnerableImages = [],
                    } = {},
                  } = row;
                  const otherImages = vulnerableImages.join(', ');
                  return (
                    <div
                      className="truncate"
                      title={otherImages}>
                      {row.value}
                    </div>
                  );
                },
                width: 200,
              },
              {
                Header: 'Description',
                accessor: 'description',
                Cell: row => (
                  <div
                    className="truncate"
                    title={row.value}>
                    {row.value}
                  </div>
                ),
                width: 300,
              },
            ]} />
        </div>
        {
          this.state.isVulnerabilityModalOpen && this.state.cveData ? (
            <VulnerabilityModal
              data={this.state.cveData}
              onRequestClose={() => {
                this.setState({
                  isVulnerabilityModalOpen: false,
                  cveData: null
                });
              }}
            />
          ) : null
        }
      </div>
    );
  }
}
function mapStateToProps(state) {
  return {
    alertPanelHistoryBound: state.get('alertPanelHistoryBound') || [],
    globalSearchQuery: state.get('globalSearchQuery') || [],
    topStats: state.getIn(['cve', 'top_exploits']) || [],
    groupedTopExploits: state.getIn(['cve', 'top_exploits_grouped']),
    attackPaths: state.getIn(['topAttackPaths', 'data']),
    attackPathsLoading: state.getIn(['topAttackPaths', 'status', 'loading'])
  };
}

export default connect(
  mapStateToProps, {
  getTopVulnerableActiveContainersAction,
  getAttackPathsAction,
  downloadMostExploitableAction,
}
)(pollable()(TopExploitableVulnerabilities));
