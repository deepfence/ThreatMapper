import React from 'react';
import { connect } from 'react-redux';
import { formValueSelector } from 'redux-form/immutable';

import { isEqual } from 'lodash';
import MaskForm from './mask-form';
import {
  nodeFilterValueSelector, resetTablePageIndexSelector,
} from '../../../selectors/node-filters';
import { DfTableV2 } from '../../common/df-table-v2'
import pollable from '../../common/header-view/pollable';
import {
  getAlertsV2Action,
  deleteDocsByIdAction,
  unmaskDocsAction,
  genericMaskDocsAction,
  requestManualAlertNotification,
} from '../../../actions/app-actions';
import { VulnerabilityModal } from '../vulnerability-modal';

const maskOptionsMap = {
  host: [
    {
      type: 'radio',
      id: 'mask_across_nodes_and_images',
      name: 'masking_docs',
      label: 'Mask across all hosts, images and containers',
      value: 'mask_across_nodes',
    },
    {
      type: 'radio',
      id: 'mask_across_nodes',
      name: 'masking_docs',
      label: 'Mask across all hosts',
      value: 'host||mask_across_nodes', // added host|| because node_type of host is required by backend and we retrieved it later
    },
    {
      type: 'radio',
      id: 'mask_this_node',
      name: 'masking_docs',
      label: 'Mask only on this host',
      value: 'host||mask_this_node',
      defaultValue: 'host||mask_this_node',
    },
  ],
  container_image: [
    {
      type: 'radio',
      id: 'mask_across_nodes',
      name: 'masking_docs',
      label: 'Mask across all hosts, images and containers',
      value: 'mask_across_nodes',
    },
    {
      type: 'radio',
      id: 'mask_across_images',
      name: 'masking_docs',
      label: 'Mask across all images',
      value: 'container_image||mask_across_nodes', // added container_image || because node_type of container_image is required by backend and we retrieved it later
    },
    {
      type: 'radio',
      id: 'mask_this_image',
      name: 'masking_docs',
      label: 'Mask only on this image',
      value: 'container_image||mask_this_image',
      defaultValue: 'container_image||mask_this_image',
    },
  ],
  container: [
    {
      type: 'radio',
      id: 'mask_across_nodes',
      name: 'masking_docs',
      label: 'Mask across all hosts, images and containers',
      value: 'mask_across_nodes',
    },
    {
      type: 'radio',
      id: 'mask_across_containers',
      name: 'masking_docs',
      label: 'Mask across all containers',
      value: 'container||mask_across_containers', // added container_image || because node_type of container_image is required by backend and we retrieved it later
    },
    {
      type: 'radio',
      id: 'mask_this_container',
      name: 'masking_docs',
      label: 'Mask only on this container',
      value: 'container||mask_this_container',
      defaultValue: 'container||mask_this_container',
    },
  ]
}
const getMaskOptionsType = (nodeType) => {
  if (!nodeType) {
    throw new Error('No nodeType found!')
  }
  return maskOptionsMap[nodeType];
}


class VulnerabilityTableV2 extends React.Component {
  constructor(props) {
    super(props);
    this.getVulnerabilities = this.getVulnerabilities.bind(this);
    this.tableChangeHandler = this.tableChangeHandler.bind(this);
    this.handlePageChange = this.handlePageChange.bind(this);
    this.handleRowClick = this.handleRowClick.bind(this);
    this.deleteDocs = this.deleteDocs.bind(this);
    this.unmaskDocs = this.unmaskDocs.bind(this);
    this.maskDocs = this.maskDocs.bind(this);
    this.handleNotify = this.handleNotify.bind(this);
    this.updatePage = this.updatePage.bind(this);
    this.state = {
      isVulnerabilityModalOpen: false,
      cveData: null,
      deletedValues: [],
      page: 0
    }
  }


  handleRowClick(rowInfo) {
    const {
      original: row,
    } = rowInfo;
    const modalData = {
      _source: {
        ...row
      },
      _id: row.doc_id,
      _type: row.type,
    };
    this.setState({
      isVulnerabilityModalOpen: true,
      cveData: modalData
    });
  }

  tableChangeHandler(params = {}) {
    // pollable: on any change in the DF Table params, update the polling params,
    // which will update and restart polling with new params.
    const { updatePollParams } = this.props;
    updatePollParams(params);
  }

  handlePageChange(pageNumber) {
    this.setState({
      page: pageNumber
    }, () => {
      this.tableChangeHandler({
        page: pageNumber
      })
    })
  }

  deleteDocs(selectedDocIndex = {}) {
    /* eslint-disable no-underscore-dangle */
    const paramList = Object.keys(selectedDocIndex).map(key => ({
      _id: selectedDocIndex[key].doc_id,
      _type: selectedDocIndex[key].type,
      _index: selectedDocIndex[key].doc_index,
    }));
    const params = paramList.reduce((acc, param) => {
      acc.index_name = param._index;
      acc.doc_type = param._type;
      acc.ids = [
        ...acc.ids,
        param._id,
      ];
      return acc;
    }, { ids: [] });
    /* eslint-enable */
    const {
      deleteDocsByIdAction: action,
    } = this.props;
    // eslint-disable-next-line react/no-access-state-in-setstate
    this.setState({deletedValues: [...this.state.deletedValues, ...params.ids]});

    // call parent callback function to update graph and count chart
    const promise = action(params);
    promise.then(() => {
      this.props.onRowActionCallback();
    });
    return promise;
  }

  unmaskDocs(selectedDocIndex = {}) {
    const params = {
      docs: Object.keys(selectedDocIndex).map(key => ({
        _id: selectedDocIndex[key].doc_id,
        _index: selectedDocIndex[key].doc_index,
      }))
    };

    const {
      unmaskDocsAction: action,
    } = this.props;
    // Mask and unmask will reset page to 1
    this.handlePageChange(0)

    // call parent callback function to update graph and count chart
    const promise = action(params);
    promise.then(() => {
      this.props.onRowActionCallback();
    })
    return promise;
  }

  maskDocs(selectedDocIndex = {}) {
    /* eslint-disable no-underscore-dangle */
    const params = Object.keys(selectedDocIndex).map(key => ({
      _id: selectedDocIndex[key].doc_id,
      _index: selectedDocIndex[key].doc_index,
    }));
    /* eslint-enable */

    const {
      genericMaskDocsAction: action,
      maskDocs
    } = this.props;
    // Mask and unmask will reset page to 1
    this.handlePageChange(0)

    const payload = {
      docs: params,
    };
    /**
     * there are 3 cases to send payload
     * i) only this node or image needs mask_across_nodes: false, node_type: host or container_image
     * ii) across nodes needs mask_across_nodes: true, node_type: host or container_image
     * iii) across nodes and images needs mask_across_nodes: true
     */
    const [node, value] = maskDocs.split('||');
    if (value !== undefined) {
      payload.mask_across_nodes = value === 'mask_across_nodes' || value === 'mask_across_containers';
      payload.node_type = node;
    } else {
      payload.mask_across_nodes = node === 'mask_across_nodes'
    }

    // call parent callback function to update graph and count chart
    const promise = action(payload);
    promise.then(() => {
      this.props.onRowActionCallback();
    });
    return promise;
  }

  handleNotify(selectedDocIndex = {}) {
    /* eslint-disable no-underscore-dangle */
    const params = Object.keys(selectedDocIndex).map(key => ({
      _id: selectedDocIndex[key].doc_id,
      _type: selectedDocIndex[key].type,
      _index: selectedDocIndex[key].doc_index,
    }));
    /* eslint-enable */
    const {
      requestManualAlertNotification: action,
    } = this.props;
    return action(params);
  }

  componentDidMount() {
    const {
      registerPolling,
      startPolling
    } = this.props;
    registerPolling(this.getVulnerabilities);
    startPolling();
  }

  /**
   *
   * Mask and unmask will reset page to 1
   * Toggle mask will reset page to 1
   * Filters and from bound changed will reset page to 1
   */
  componentDidUpdate(oldProps) {
    const newProps = this.props;
    const options = {};
    if (newProps.filterValues && oldProps.filterValues !== newProps.filterValues) {
      options.filters = newProps.filterValues;
    }
    if (newProps.hideMasked !== oldProps.hideMasked) {
      // Toggle mask will reset page to 1
      // eslint-disable-next-line react/no-did-update-set-state
      this.setState({
        page: 0
      });
      options.page = 0;
      options.hideMasked = newProps.hideMasked;
    }
    if (Object.keys(options).length > 0) {
      this.props.updatePollParams(options);
    }
    // Filters and from bound changed will reset page to 1
    if (!isEqual(oldProps.resetPageIndexData, this.props.resetPageIndexData)) {
      // eslint-disable-next-line react/no-did-update-set-state
      this.setState({
        page: 0
      });
    }
  }

  async updatePage() {
    /**
     * 1. Reduce page by 1 only if all records are deleted from last page
     * 2. Do not reduce page by 1 when I am on 1st page
     */

    if (this.state.deletedValues.length <= 0) {
      return;
    }

    const currentPage = this.state.page + 1;
    const pageSize = 20;
    const totalRecords = this.props.total;
    const recordsOnLastPage = (totalRecords % pageSize) || pageSize;
    const isLastPage = Math.ceil(totalRecords / pageSize) === currentPage;
    // last page may have exact records of pageSize or less
    const isSelectedAllRecords = this.state.deletedValues.length === recordsOnLastPage;
    if (currentPage !== 1 && isLastPage && isSelectedAllRecords) {
      this.handlePageChange(this.state.page - 1);
    } else {
      this.props.updatePollParams({});
    }
    this.setState({
      deletedValues: [],
    });
  
  }

  getVulnerabilities(params) {
    const {
      getAlertsV2Action: action,
      filterValues = {},
    } = this.props;

    // eslint-disable-next-line no-nested-ternary
    const hideMasked = typeof params.hideMasked === 'boolean' ? params.hideMasked : (typeof this.props.hideMasked === 'boolean' ? this.props.hideMasked : true);

    const {
      page = 0,
      pageSize = 20,
      sorted = [],
      // eslint-disable-next-line react/destructuring-assignment
      alertPanelHistoryBound = this.props.alertPanelHistoryBound || [],
      // eslint-disable-next-line react/destructuring-assignment
      globalSearchQuery = this.props.globalSearchQuery || [],
      initiatedByPollable,
    } = params;

    const sortArr = sorted.map(el => (
      {
        sort_by: el.id,
        sort_order: el.desc ? 'desc' : 'asc',
      }
    ));

    const sortField = sortArr.length ? sortArr[sortArr.length - 1] : {
      sort_by: 'cve_severity',
      sort_order: 'desc'
    };

    const tableFilters = params.filters || filterValues;
    const nonEmptyFilters = Object.keys(tableFilters).filter(
      key => tableFilters[key].length
    ).reduce((acc, key) => {
      // replacing back the dot which was removed redux-form as it considers that a nested field.
      acc[[key.replace('-', '.')]] = tableFilters[key];
      return acc;
    }, {});

    const {
      ...nodeFilters // apart from masked, all the node_type filters
    } = nonEmptyFilters;

    // once filters are implemented, hideMasked can be removed.
    const toggleMaskFilter =  hideMasked;
    const filters = {
      ...(toggleMaskFilter ? { masked: false } : {}),
      type: ['cve'],
      // eslint-disable-next-line react/destructuring-assignment
      cve_container_image: this.props.imageName,
      // eslint-disable-next-line react/destructuring-assignment
      scan_id: this.props.scanId,
    };
  
   const from = page ? page * pageSize : page;

    const apiParams = {
      type: 'cve',
      query: {
        from,
        size: pageSize,
        ...sortField,
        lucene_query: globalSearchQuery,
        // Conditionally adding number and time_unit fields
        ...(alertPanelHistoryBound.value
          ? { number: alertPanelHistoryBound.value.number } : {}),
        ...(alertPanelHistoryBound.value
          ? { time_unit: alertPanelHistoryBound.value.time_unit } : {}),
      },
      filters,
      node_filters: nodeFilters,
      initiatedByPollable,
    };
    return action(apiParams);
  }

  render() {
    const {
      alerts = [],
      total,
      updatePollParams
    } = this.props;

    const columns = [
      {
        Header: 'CVE Id',
        accessor: 'cve_id',
        width: 100,
      },
      {
        Header: 'Package',
        accessor: 'cve_caused_by_package',
        width: 100,
      },
      {
        Header: 'Severity',
        accessor: 'cve_severity',
        Cell: cell => (
          <div className={`${cell.value}-severity`}>
            {cell.value}
          </div>
        ),
        width: 70
      },
      {
        Header: 'Summary',
        accessor: 'cve_description',
        minWidth: 100,
        width: 300,
      },
      {
        Header: 'CVE Link',
        accessor: 'cve_link',
        Cell: cell => (
          <div className="truncate">
            <a
              href={cell.value}
              target="_blank"
              rel="noopener noreferrer"
              onClick={e => e.stopPropagation()}
            >
              {cell.value}
            </a>
          </div>
        )
      },
    ];

    return (
      <div
        className="alert-table-view"
      >
        <div className="mask-filter vulnerability-filter">
          <MaskForm />
        </div>

        <DfTableV2
          columns={columns}
          showPagination
          defaultPageSize={20}
          totalRows={total}
          name="cve-table"
          manual
          data={alerts}
          getRowStyle={(row) => ({
            opacity: row.original.masked === 'true' ? 0.5 : 1
          })}
          onRowClick={(row) => this.handleRowClick(row)}
          columnCustomizable
          enableSorting
          onPageChange={this.handlePageChange}
          onSortChange={(sorted) => {
            this.tableChangeHandler({
              sorted
            })
          }}
          page={this.state.page}
          multiSelectOptions={{
            actions: [
              {
                name: 'Notify',
                icon: (<i className="fa fa-bell-o active-color cursor" />),
                onClick: this.handleNotify,
              },
              {
                name: 'mask',
                userRole: 'admin',
                icon: (<i className="fa fa-eye-slash cursor" />),
                onClick: this.maskDocs,
                postClickSuccess: updatePollParams,
                showConfirmationDialog: true,
                confirmationDialogParams: {
                  dialogTitle: 'Mask these records?',
                  dialogBody: 'Are you sure you want to mask the selected records?',
                  additionalInputs: alerts[0]?.node_type ? getMaskOptionsType(alerts[0].node_type) : [],
                  confirmButtonText: 'Yes, mask',
                  cancelButtonText: 'No, Keep',
                  contentStyles: {
                    height: '300px',
                  },
                },
              },
              {
                name: 'Unmask',
                userRole: 'admin',
                icon: (<i className="fa fa-eye cursor" />),
                onClick: this.unmaskDocs,
                postClickSuccess: updatePollParams,
                showConfirmationDialog: true,
                confirmationDialogParams: {
                  dialogTitle: 'Unmask these records?',
                  dialogBody: 'Are you sure you want to unmask the selected records?',
                  confirmButtonText: 'Yes, Unmask',
                  cancelButtonText: 'No, Keep',
                },
              },
              {
                name: 'Delete',
                icon: (<i className="fa fa-trash-o red cursor" />),
                onClick: this.deleteDocs,
                postClickSuccessTODO: this.removeDocs,
                postClickSuccess: this.updatePage,
                showConfirmationDialog: true,
                postClickSuccessDelayInMs: 2000,
                confirmationDialogParams: {
                  dialogTitle: 'Delete these records?',
                  dialogBody: 'Are you sure you want to Delete the selected records?',
                  confirmButtonText: 'Yes, Delete',
                  cancelButtonText: 'No, Keep',
                },
              },
            ],
            columnConfig: {
              accessor: 'doc_id'
            }
          }}
        />
        {
          this.state.isVulnerabilityModalOpen && this.state.cveData ? (
            <VulnerabilityModal
              data={this.state.cveData}
              onRequestClose={() => {
                this.setState({
                  isVulnerabilityModalOpen: false,
                  cveData: null
                });
              }}
            />
          ) : null
        }
      </div>
    );
  }
}

const maskFormSelector = formValueSelector('cve-mask-form');
function mapStateToProps(state) {
  return {
    alerts: state.getIn(['alertsView', 'data']),
    total: state.getIn(['alertsView', 'total']),
    filterValues: nodeFilterValueSelector(state),
    hideMasked: maskFormSelector(state, 'hideMasked') ?? true,
    maskDocs: state.getIn(['form', 'dialogConfirmation', 'values', 'masking_docs']),
    resetPageIndexData: resetTablePageIndexSelector(state),
  };
}

const connectedTable = connect(mapStateToProps, {
  getAlertsV2Action,
  deleteDocsByIdAction,
  unmaskDocsAction,
  genericMaskDocsAction,
  requestManualAlertNotification,
})(VulnerabilityTableV2);

export default pollable()(connectedTable);;
