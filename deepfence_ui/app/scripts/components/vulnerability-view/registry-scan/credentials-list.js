/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
/* eslint-disable react/no-access-state-in-setstate */
/* eslint-disable react/destructuring-assignment */
import React from 'react';
import { Map } from 'immutable';
import { formValueSelector } from 'redux-form/immutable';
import { connect } from 'react-redux';
import Tippy from '@tippyjs/react';
import { DfTableV2 } from '../../common/df-table-v2';
import AppLoader from '../../loader';
import { dateTimeFormat } from '../../../utils/time-utils';
import RegistryImageList from './image-list';
import {
  scanRegistryImagesAction,
  listRegistryCredentialsAction,
  deleteRegistryCredentialsAction,
  clearScanContainerImageRegistryAction,
  secretsScanRegistryImagesAction,
  showModal,
  toaster,
} from '../../../actions/app-actions';
import NotificationToaster from '../../common/notification-toaster/notification-toaster';
import { getUserRole } from '../../../helpers/auth-helper';
import injectModalTrigger from '../../common/generic-modal/modal-trigger-hoc';
import { DfDropDownMenu } from '../../common/df-dropdown/index';
import RegistryScanForm from "./registry-scan-form";
import SecretsScanForm from "../../secret-scan-view/registry-scan/secrets-scan-form";
import MORE_IMAGE from '../../../../images/more.svg';

const loaderStyle = {
  top: '6.8%',
  left: '50%',
};

class RegistryCredentialsList extends React.PureComponent {
  constructor(props) {
    super(props);
    this.handleDeleteDialog = this.handleDeleteDialog.bind(this);
    this.renderSubComponent = this.renderSubComponent.bind(this);
    this.deleteRegistry = this.deleteRegistry.bind(this);
    this.getRegistry = this.getRegistry.bind(this);
    this.onExpandedChange = this.onExpandedChange.bind(this);
    this.triggerStartBulkScan = this.triggerStartBulkScan.bind(this);
    this.triggerStopCVEScanModal = this.triggerStopCVEScanModal.bind(this);
    this.renderVulnerabilityScanModalContent = this.renderVulnerabilityScanModalContent.bind(this);
    this.renderSecretsScanModalContent = this.renderSecretsScanModalContent.bind(this);
    this.scanMultipleregistries = this.scanMultipleregistries.bind(this);
    this.scanRegistryImages = this.scanRegistryImages.bind(this);
    this.bulkStopCVEScan = this.bulkStopCVEScan.bind(this);
    this.triggerStartSecretsScanModal = this.triggerStartSecretsScanModal.bind(this);
    this.nodeActionOptions = [
      {
        label: 'Start Vulnerability Scan',
        onClick: this.triggerStartBulkScan,
        enabled: true,
      },
      {
        label: 'Stop Vulnerability Scan',
        onClick: this.triggerStopCVEScanModal,
        enabled: true,
      },
      {
        label: 'Start Secrets Scan',
        onClick: this.triggerStartSecretsScanModal,
        enabled: true,
      },
    ];
    this.state = {
      expandedRowIndex: {
        0: {},
      },
    };
  }

  componentDidMount() {
    this.getRegistry();
  }

  onExpandedChange(rowInfo) {
    let expandedRowIndex = {
      ...this.state.expandedRowIndex,
    };
    const pageIndex = rowInfo.index;
    if (expandedRowIndex[pageIndex]) {
      expandedRowIndex[pageIndex] = !expandedRowIndex[pageIndex];
    } else {
      expandedRowIndex = {
        [pageIndex]: {},
      };
    }
    this.setState({
      expandedRowIndex,
    });
  }

  getRegistry() {
    const { listRegistryCredentialsAction: action, registryType } = this.props;
    action({
      registryType,
    });
  }

  deleteRegistry(registryId) {
    const { deleteRegistryCredentialsAction: action, toaster: toasterAction } =
      this.props;
    const params = {
      registryId,
    };
    const promise = action(params);
    promise.then(response => {
      if (response instanceof Error) {
        toasterAction('Registry deletion failed due to an unknown error');
      }
      this.getRegistry();
    });

    return promise;
  }

  renderSubComponent(row) {
    return (
      <div className="sub-row">
        <RegistryImageList
          registryId={row.row.original.id}
          registryType={this.props.registryType}
        />
      </div>
    );
  }

  handleDeleteDialog(registryId) {
    const params = {
      dialogTitle: 'Delete Registry Credentials?',
      dialogBody: 'Are you sure you want to delete?',
      confirmButtonText: 'Yes, Delete Credentials',
      cancelButtonText: 'No, Keep Credentials',
      onConfirmButtonClick: () => this.deleteRegistry(registryId),
      contentStyles: {
        width: '375px',
      },
    };
    this.props.showModal('DIALOG_MODAL', params);
  }

  renderVulnerabilityScanModalContent(props) {
    const { selectedDocIndex = {} } = props;

    return (
      <RegistryScanForm
        selectedDocIndex={selectedDocIndex}
        onSubmit={(valuesIm) => {
          const { scanType, scheduleScan, scheduleInterval,
            scanRegistryType, priority } = valuesIm.toJS();
          const params = {
            selectedDocIndex,
            scanType,
            scheduleScan,
            scheduleInterval,
            scanRegistryType,
            priority
          };
          this.scanMultipleregistries(params);
        }}
      />
    );
  }

  renderSecretsScanModalContent(props) {
    const { selectedDocIndex = {} } = props;

    return (
      <SecretsScanForm
        selectedDocIndex={selectedDocIndex}
        onSubmit={(valuesIm) => {
          const { scheduleScan, scheduleInterval,
            scanRegistryType, registry_image_tags: registryImageTags } = valuesIm.toJS();
          const params = {
            selectedDocIndex,
            scheduleScan,
            scheduleInterval,
            scanRegistryType,
            registryImageTags,
          };
          this.scanMultipleregistriesForSecrets(params);
        }}
      />
    );
  }

  scanMultipleregistries(params) {
    const { selectedDocIndex = {} } = params;
    const registryIds = Object.keys(selectedDocIndex).map(index => selectedDocIndex[index].id);
    registryIds.forEach(registryId => {
      this.scanRegistryImages(params, registryId);
    });
  }

  scanMultipleregistriesForSecrets(params) {
    const { selectedDocIndex = {} } = params;
    const registryIds = Object.keys(selectedDocIndex).map(index => selectedDocIndex[index].id);
    registryIds.forEach(registryId => {
      this.scanRegistryImagesForSecrets(params, registryId);
    });
  }

  triggerStartBulkScan(selectedDocIndex) {
    const { clearScanContainerImageRegistryAction: clearAction } = this.props;
    const modalProps = {
      title: "Registry Vulnerability Scan",
      modalContent: this.renderVulnerabilityScanModalContent,
      modalContentProps: {
        selectedDocIndex,
      },
      contentStyles: {
        width: "400px",
      },
      onHide: () => {
        clearAction();
      },
    };
    const { triggerModal } = this.props;
    triggerModal("GENERIC_MODAL", modalProps);
  }

  triggerStopCVEScanModal(selectedDocIndex) {
    const modalProps = {
      dialogTitle: 'Stop Vulnerability Scan',
      dialogBody: 'This will only stop the scans that are in queued state. It will not stop scans that are currently running. Do you want to continue ?',
      confirmButtonText: 'Yes',
      cancelButtonText: 'No',
      onConfirmButtonClick: paramsIm => this.bulkStopCVEScan(selectedDocIndex, paramsIm),
    };
    const { triggerModal } = this.props;
    return triggerModal('DIALOG_MODAL', modalProps);
  }

  triggerStartSecretsScanModal(selectedDocIndex) {
    const { clearScanContainerImageRegistryAction: clearAction } = this.props;
    const modalProps = {
      title: "Registry Secrets Scan",
      modalContent: this.renderSecretsScanModalContent,
      modalContentProps: {
        selectedDocIndex,
      },
      contentStyles: {
        width: "400px",
      },
      onHide: () => {
        clearAction();
      },
    };
    const { triggerModal } = this.props;
    triggerModal("GENERIC_MODAL", modalProps);
  }

  scanRegistryImages(params, registryId) {
    const {
      scanRegistryImagesAction: action,
      resetSelection,
      registryImageTagsValues,
    } = this.props;

    const { scanType, scheduleScan, scheduleInterval,
      scanRegistryType, priority } =
      params;

    const scanRegistryTypeValue = scanRegistryType && scanRegistryType === "scanAll" ? '' : scanRegistryType;
    let priorityValueCheck = !!(priority && priority.length > 0);
    if (scanRegistryType && scanRegistryType === "scanAll") {
      priorityValueCheck = false;
    }
    const ImageTagsValues = registryImageTagsValues && registryImageTagsValues.map(el => el.value);
    const schedule = !!(scheduleScan && scheduleScan[0]);
    const scanAllImages = !!(scanRegistryType && scanRegistryType === "scanAll");

    if (schedule && scheduleInterval) {
      // do 2 api calls
      const apiAction = "schedule_vulnerability_scan";
      const actionArgs = {
        cron: `0 1 */${scheduleInterval} * *`,
        scan_type: scanType,
        resources: [],
      };

      const actionArgs2 = {
        cron: `0 2 * * *`,
        scan_type: scanType,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: false,
          registry_scan_type: scanRegistryTypeValue,
          priority: priorityValueCheck,
          image_tags: ImageTagsValues,
          scan_type: scanType,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };
      const apiParams2 = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: true,
          registry_scan_type: scanRegistryTypeValue,
          priority: priorityValueCheck,
          image_tags: ImageTagsValues,
          scan_type: scanType,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs2,
      };
      const promises = [];
      promises.push(action(apiParams));
      promises.push(action(apiParams2));
      return Promise.all(promises).then(() => resetSelection());
    } if (scheduleInterval) {
      const apiAction = "schedule_vulnerability_scan";
      const actionArgs = {
        cron: `0 1 */${scheduleInterval} * *`,
        scan_type: scanType,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: schedule,
          registry_scan_type: scanRegistryTypeValue,
          priority: priorityValueCheck,
          image_tags: ImageTagsValues,
          scan_type: scanType,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };
      const promise = action(apiParams);
      promise.then(() => resetSelection());
      return promise;
    } if (schedule) {
      // do 2 api call

      const apiAction = "cve_scan_start";
      const actionArgs = {
        scan_type: scanType,
        resources: [],
      };

      const apiAction2 = "schedule_vulnerability_scan";
      const actionArgs2 = {
        cron: `0 2 * * *`,
        scan_type: scanType,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: false,
          registry_scan_type: scanRegistryTypeValue,
          priority: priorityValueCheck,
          image_tags: ImageTagsValues,
          scan_type: scanType,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };

      const apiParams2 = {
        action: apiAction2,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: true,
          registry_scan_type: scanRegistryTypeValue,
          priority: priorityValueCheck,
          image_tags: ImageTagsValues,
          scan_type: scanType,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs2,
      };
      const promises = [];
      promises.push(action(apiParams));
      promises.push(action(apiParams2));
      return Promise.all(promises).then(() => resetSelection());
    }
    // nothing is selected
    const apiAction = "cve_scan_start";
    const actionArgs = {
      scan_type: scanType,
      resources: [],
    };

    const apiParams = {
      action: apiAction,
      node_type: "registry_image",
      registry_images: {
        all_registry_images: scanAllImages,
        only_new_images: schedule,
        registry_scan_type: scanRegistryTypeValue,
        priority: priorityValueCheck,
        image_tags: ImageTagsValues,
        scan_type: scanType,
        image_name_with_tag_list: [],
        registry_id: registryId,
      },
      action_args: actionArgs,
    };
    const promise = action(apiParams);
    promise.then(() => resetSelection());
    return promise;
  }

  scanRegistryImagesForSecrets(params, registryId) {
    const {
      secretsScanRegistryImagesAction: action,
      resetSelection = () => {},
    } = this.props;

    const { scheduleScan, scheduleInterval,
      scanRegistryType, registryImageTags } =
      params;

    const scanRegistryTypeValue = scanRegistryType && scanRegistryType === "scanAll" ? '' : scanRegistryType;

    const ImageTagsValues = registryImageTags && registryImageTags.map(el => el.value);
    const schedule = !!(scheduleScan && scheduleScan[0]);
    const scanAllImages = !!(scanRegistryType && scanRegistryType === "scanAll");

    if (schedule && scheduleInterval) {
      // do 2 api calls
      const apiAction = "schedule_secret_scan";
      const actionArgs = {
        cron: `0 1 */${scheduleInterval} * *`,
        resources: [],
      };

      const actionArgs2 = {
        cron: `0 2 * * *`,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: false,
          registry_scan_type: scanRegistryTypeValue,
          image_tags: ImageTagsValues,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };
      const apiParams2 = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: true,
          registry_scan_type: scanRegistryTypeValue,
          image_tags: ImageTagsValues,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs2,
      };
      const promises = [];
      promises.push(action(apiParams));
      promises.push(action(apiParams2));
      return Promise.all(promises).then(() => resetSelection());
    } if (scheduleInterval) {
      const apiAction = "schedule_secret_scan";
      const actionArgs = {
        cron: `0 1 */${scheduleInterval} * *`,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: schedule,
          registry_scan_type: scanRegistryTypeValue,
          image_tags: ImageTagsValues,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };
      const promise = action(apiParams);
      promise.then(() => resetSelection());
      return promise;
    } if (schedule) {
      // do 2 api call

      const apiAction = "secret_scan_start";
      const actionArgs = {
        resources: [],
      };

      const apiAction2 = "schedule_secret_scan";
      const actionArgs2 = {
        cron: `0 2 * * *`,
        resources: [],
      };

      const apiParams = {
        action: apiAction,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: false,
          registry_scan_type: scanRegistryTypeValue,
          image_tags: ImageTagsValues,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs,
      };

      const apiParams2 = {
        action: apiAction2,
        node_type: "registry_image",
        registry_images: {
          all_registry_images: scanAllImages,
          only_new_images: true,
          registry_scan_type: scanRegistryTypeValue,
          image_tags: ImageTagsValues,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
        action_args: actionArgs2,
      };
      const promises = [];
      promises.push(action(apiParams));
      promises.push(action(apiParams2));
      return Promise.all(promises).then(() => resetSelection());
    }
    // nothing is selected
    const apiParams = {
      action: "secret_scan_start",
      node_type: "registry_image",
      registry_images: {
        all_registry_images: scanAllImages,
        only_new_images: schedule,
        registry_scan_type: scanRegistryTypeValue,
        image_tags: ImageTagsValues,
        image_name_with_tag_list: [],
        registry_id: registryId,
      },
      action_args: {},
    };
    const promise = action(apiParams);
    promise.then(() => resetSelection());
    return promise;
  }

  bulkStopCVEScan(selectedDocIndex = {}) {
    const {
      scanRegistryImagesAction: action,
      toaster: toast,
    } = this.props;
    const registryIds = Object.keys(selectedDocIndex).map(index => selectedDocIndex[index].id);
    return Promise.all(registryIds.map((registryId) => {
      const apiParams = {
        action: 'cve_scan_stop',
        node_type: 'registry_image',
        registry_images: {
          all_registry_images: true,
          image_name_with_tag_list: [],
          registry_id: registryId,
        },
      };
      return action(apiParams);
    })).then(results => {
      const hasError = !!results.find(response => response.error);
      if (hasError) {
        console.error(results);
        toast(`ERROR: Request to stop vulnerability scan failed`);
      }
      toast('Request to stop vulnerability scan successfully queued');
    });
  }

  render() {
    const userRole = getUserRole();
    const {
      dataIm = Map(),
      loadingIm = Map(),
      registryType,
      isToasterVisible,
      triggerEdit,
    } = this.props;

    const data = dataIm.get(registryType, []);
    const loading = loadingIm.get(registryType);
    return (
      <div>
        <DfTableV2
          data={data}
          onRowClick={rowInfo => this.onExpandedChange(rowInfo)}
          LoadingComponent={
            loading ? () => <AppLoader small style={loaderStyle} /> : undefined
          }
          columns={[
            {
              Header: 'Created',
              id: 'created_at',
              accessor: row => {
                if (row.created_at) {
                  return dateTimeFormat(row.created_at);
                }
                return '';
              },
              maxWidth: 200,
              sortable: false, // Disabling sort because it messes up with expanded row index
            },
            {
              Header: 'Name',
              accessor: 'name',
              sortable: false, // Disabling sort because it messes up with expanded row index
              Cell: row => <span title={row.value}>{row.value}</span>,
            },
            {
              Header: 'Total Images',
              accessor: 'unique_images_count',
              maxWidth: 150,
              sortable: false, // Disabling sort because it messes up with expanded row index
            },
            {
              Header: 'Total Tags',
              accessor: 'total_image_tags_count',
              maxWidth: 150,
              sortable: 150,
            },
            {
              Header: 'Total Scanned',
              accessor: 'total_scanned',
              maxWidth: 150,
              sortable: false, // Disabling sort because it messes up with expanded row index
            },
            {
              Header: 'In Progress',
              accessor: 'scan_in_progress',
              maxWidth: 150,
              sortable: false, // Disabling sort because it messes up with expanded row index
            },
            {
              Header: 'Credentials',
              accessor: row => {
                const { credentials } = row;
                const forDisplay = Object.keys(credentials).reduce(
                  (acc, key) => {
                    const userFriendlyKey = key.replace(/_/g, ' ');
                    acc[userFriendlyKey] = credentials[key];
                    return acc;
                  },
                  {}
                );
                return JSON.stringify(forDisplay);
              },
              id: 'credentials',
              sortable: false,
              Cell: row => <span title={row.value}>{row.value}</span>,
              minWidth: 350,
            },
            {
              Header: '',
              accessor: 'id',
              Cell: row => (
                <Tippy
                  arrow
                  interactive
                  trigger='click'
                  hideOnClick
                  placement='bottom'
                  zIndex={1}
                  allowHTML
                  content={(
                    <div className="table-row-actions-popup">
                      <i
                        className="fa fa-lg fa-trash-o"
                        style={{ color: 'red', marginRight: '10px' }}
                        onClick={() => this.handleDeleteDialog(row.value)}
                      />
                      <i
                        className="fa fa-lg fa-pencil"
                        onClick={ev => {
                          ev.stopPropagation();
                          const { original } = row.row;
                          const initialValues = {
                            name: original.name,
                            non_secret: original.credentials,
                            id: original.id,
                          };
                          triggerEdit({ initialValues });
                        }}
                      />
                    </div>
                  )}>
                  <img
                    src={MORE_IMAGE}
                    alt="more"
                    className="table-row-actions-target"
                    onClick={e => {
                      e.stopPropagation();
                    }}
                  />
                </Tippy>
              ),
              style: { textAlign: 'left' },
              sortable: false,
              show: userRole === 'admin',
              maxWidth: 60,
            },
          ]}
          multiSelectOptions={{
            actions: [
              {
                name: 'Scan',
                IconComponent: DfDropDownMenu,
                componentParams: {
                  alignment: 'right',
                  label: 'Actions',
                  options: this.nodeActionOptions,
                },
                onClick: () => ({}),
              },
            ],
            columnConfig: {
              accessor: 'id',
            },
          }}
          renderRowSubComponent={({ row }) => this.renderSubComponent({ row })}
          SubComponent={component => (
            <div className="sub-row">
              <RegistryImageList
                registryId={component.row.id}
                registryType={registryType}
              />
            </div>
          )}
        />
        {isToasterVisible && <NotificationToaster />}
      </div>
    );
  }
}

const cveScanFormSelector = formValueSelector('cve-scan');
const mapStateToProps = state => ({
  dataIm: state.getIn([
    'cve',
    'container_image_registry',
    'list_credentials',
    'data',
  ]),
  loadingIm: state.getIn([
    'cve',
    'container_image_registry',
    'list_credentials',
    'loading',
  ]),
  errorMessageIm: state.getIn([
    'cve',
    'container_image_registry',
    'list_credentials',
    'error',
    'message',
  ]),
  isToasterVisible: state.get('isToasterVisible'),
  ImageIndexIm: state.getIn(['cve', 'container_image_registry', 'images']),
  totalIndexIm: state.getIn(['cve', 'container_image_registry', 'total']),
  uniqueImageCountIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'uniqueImageCount',
  ]),
  registryImageTagsValues: cveScanFormSelector(state, 'registry_image_tags'),
});
export default connect(mapStateToProps, {
  secretsScanRegistryImagesAction,
  scanRegistryImagesAction,
  listRegistryCredentialsAction,
  deleteRegistryCredentialsAction,
  clearScanContainerImageRegistryAction,
  showModal,
  toaster,
})(injectModalTrigger(RegistryCredentialsList));
