/* eslint-disable class-methods-use-this */
/* eslint-disable react/destructuring-assignment */
import React from 'react';
import moment from 'moment';
import { Map } from 'immutable';
import { connect } from 'react-redux';
import ReactTooltip from 'react-tooltip';
// import DFTable from '../../common/df-table/index';
import { DfTableV2 } from '../../common/df-table-v2';
import AppLoader from '../../loader';
import { dateTimeFormat } from '../../../utils/time-utils';
import NotificationToaster from '../../common/notification-toaster/notification-toaster';
import {
  scanRegistryImagesAction,
  listRegistryImagesAction,
  clearScanContainerImageRegistryAction,
  toaster,
  triggerRegistryRefreshAction,
  enumerateFiltersAction,
} from '../../../actions/app-actions';
import pollable from '../../common/header-view/pollable';
import injectModalTrigger from '../../common/generic-modal/modal-trigger-hoc';
import CVEScanForm from './cve-scan-form';
import NodesFilter from '../../../charts/nodes-filter';
import { DfDropDownMenu } from '../../common/df-dropdown/index';
import { createCustomSelector } from '../../../selectors/node-filters';

const loaderStyle = {
  top: '50%',
};

class RegistryImageList extends React.PureComponent {
  constructor(props) {
    super(props);
    this.scanRegistryImages = this.scanRegistryImages.bind(this);
    this.getImages = this.getImages.bind(this);
    this.showFormHandler = this.showFormHandler.bind(this);
    this.handlePageChange = this.handlePageChange.bind(this);
    this.triggerStopCVEScanModal = this.triggerStopCVEScanModal.bind(this);
    this.bulkStopCVEScan = this.bulkStopCVEScan.bind(this);
    this.renderModalContent = this.renderModalContent.bind(this);
    this.tableChangeHandler = this.tableChangeHandler.bind(this);
    this.triggerRefresh = this.triggerRefresh.bind(this);
    this.getFilters = this.getFilters.bind(this);
    this.nodeActionOptions = [
      {
        label: 'Start Vulnerability Scan',
        onClick: this.showFormHandler,
        enabled: true,
      },
      {
        label: 'Stop Vulnerability Scan',
        onClick: this.triggerStopCVEScanModal,
        enabled: true,
      },
    ];
  }

  componentDidMount() {
    const { registerPolling, startPolling } = this.props;
    registerPolling(this.getImages);
    startPolling();
  }

  UNSAFE_componentWillReceiveProps(newProps) {
    const {
      dispatch,
      errorMessageIm = Map(),
      registryType,
      registryId,
      initiatedByPollableIm,
      filterValues: newFilterValues,
    } = newProps;
    const newErrorMessage = errorMessageIm.getIn(
      [registryType, registryId],
      ''
    );
    const initiatedByPollable = initiatedByPollableIm.getIn(
      [registryType, registryId],
      false
    );
    if (newErrorMessage && !initiatedByPollable) {
      dispatch(toaster(newErrorMessage));
    }

    if (newFilterValues && this.props.filterValues !== newFilterValues) {
      const { updatePollParams } = this.props;
      updatePollParams({
        filters: newFilterValues,
      });
    }
  }

  componentWillUnmount() {
    // pollable: stop polling on unmount
    const { stopPolling } = this.props;
    stopPolling();
  }

  renderModalContent(props) {
    const { selectedDocIndex = {} } = props;

    return (
      <CVEScanForm
        onSubmit={valuesIm => {
          const { scanType, scheduleInterval, priority } = valuesIm.toJS();
          const params = {
            selectedDocIndex,
            scanType,
            scheduleInterval,
            priority
          };
          this.scanRegistryImages(params);
        }}
      />
    );
  }

  showFormHandler(selectedDocIndex) {
    const { clearScanContainerImageRegistryAction: clearAction } = this.props;
    const modalProps = {
      title: 'Registry Vulnerability Scan',
      modalContent: this.renderModalContent,
      modalContentProps: {
        selectedDocIndex,
      },
      contentStyles: {
        width: '400px',
      },
      onHide: () => {
        clearAction();
      },
    };
    const { triggerModal } = this.props;
    triggerModal('GENERIC_MODAL', modalProps);
  }

  triggerStopCVEScanModal(selectedDocIndex) {
    const modalProps = {
      dialogTitle: 'Stop Vulnerability Scan',
      dialogBody:
        'This will only stop the scans that are in queued state. It will not stop scans that are currently running. Do you want to continue ?',
      confirmButtonText: 'Yes',
      cancelButtonText: 'No',
      onConfirmButtonClick: paramsIm =>
        this.bulkStopCVEScan(selectedDocIndex, paramsIm),
    };
    const { triggerModal } = this.props;
    return triggerModal('DIALOG_MODAL', modalProps);
  }

  getImages(inputParams = {}) {
    const {
      refresh = false,
      initiatedByPollable,
      page = 0,
      pageSize = 20,
      sorted = [],
    } = inputParams;

    const sortArr = sorted.map(el => ({
      sort_by: el.id,
      sort_order: el.desc ? 'desc' : 'asc',
    }));
    const sortField = sortArr.length ? sortArr[sortArr.length - 1] : {};
    const {
      listRegistryImagesAction: listAction,
      filterValues = {},
      registryId,
      registryType,
    } = this.props;

    const imageFilters = inputParams.filters || filterValues;
    const nonEmptyFilters = Object.keys(imageFilters)
      .filter(key => imageFilters[key].length)
      .reduce((acc, key) => {
        // replacing back the dot which was removed redux-form as it considers that a nested field.
        acc[[key.replace('-', '.')]] = imageFilters[key];
        return acc;
      }, {});
    const params = {
      registry_id: registryId,
      registryType,
      refresh,
      size: pageSize,
      start_index: page * pageSize,
      ...sortField,
      initiatedByPollable,
      filters: {
        ...nonEmptyFilters,
        type: 'registry_image',
      },
    };

    return listAction(params).then(() => this.getFilters());
  }

  bulkStopCVEScan(selectedDocIndex) {
    const {
      registryId,
      scanRegistryImagesAction: action,
      toaster: toast,
    } = this.props;

    const imageList = Object.keys(selectedDocIndex);

    const apiParams = {
      action: 'cve_scan_stop',
      node_type: 'registry_image',
      registry_images: {
        image_name_with_tag_list: imageList,
        registry_id: registryId,
      },
    };
    return action(apiParams).then(response => {
      const { success, error: apiError } = response;
      if (success) {
        toast('Request to stop vulnerability scan successfully queued');
      } else {
        toast(`ERROR: ${apiError.message}`);
      }
    });
  }

  scanRegistryImages(params) {
    const {
      registryId,
      scanRegistryImagesAction: action,
      resetSelection,
    } = this.props;

    const { selectedDocIndex, scanType, scheduleInterval, priority } = params;

    const priorityValueCheck = !!(priority && priority.length > 0);
    const imageList = Object.keys(selectedDocIndex);

    let apiAction = 'cve_scan_start';
    let actionArgs = {
      scan_type: scanType,
      resources: [],
    };
    if (scheduleInterval) {
      apiAction = 'schedule_vulnerability_scan';
      actionArgs = {
        cron: `0 0 */${scheduleInterval} * *`,
        scan_type: scanType,
        resources: [],
      };
    }
    const apiParams = {
      action: apiAction,
      node_type: 'registry_image',
      registry_images: {
        scan_type: scanType,
        image_name_with_tag_list: imageList,
        priority: priorityValueCheck,
        registry_id: registryId,
      },
      action_args: actionArgs,
    };

    const promise = action(apiParams);
    promise.then(() => {
      try {
        resetSelection();
      } catch (e) {
        Promise.resolve();
      }
    });
    return promise;
  }

  tableChangeHandler(params = {}) {
    // pollable: on any change in the DF Table params, update the polling params,
    // which will update and restart polling with new params.
    const { updatePollParams } = this.props;
    updatePollParams(params);
  }

  handlePageChange(pageNumber) {
    this.tableChangeHandler({
      page: pageNumber,
    });
  }

  renderSubComponent(rowInfo) {
    const imageTags = rowInfo.row.original.tags;
    return (
      <DfTableV2
        data={imageTags}
        defaultPageSize={15}
        showPagination
        columns={[
          {
            Header: 'Pushed at',
            accessor: row => {
              if (row.pushed_at) {
                return dateTimeFormat(row.pushed_at);
              }
              return '';
            },
            id: 'pushed_at',
            maxWidth: 200,
          },
          {
            Header: 'Image Tag',
            accessor: 'image_tag',
            maxWidth: 150,
          },
          {
            Header: 'Platform',
            accessor: 'image_os',
            maxWidth: 150,
          },
          {
            Header: 'Size',
            accessor: 'docker_image_size',
            maxWidth: 150,
          },
          {
            Header: 'Status',
            id: 'vulnerability_scan_status',
            accessor: row => {
              let cveStatus = row.vulnerability_scan_status;
              const latestScanTimeStr = row.vulnerability_scan_status_time;
              switch (cveStatus) {
                case 'queued': {
                  cveStatus = 'Queued';
                  break;
                }
                case 'in_progress': {
                  cveStatus = 'In Progress';
                  break;
                }
                case 'error': {
                  cveStatus = 'Error';
                  break;
                }
                case 'complete': {
                  cveStatus = 'Completed';
                  break;
                }
                default:
                  cveStatus = 'Never Scanned';
              }

              let summary = cveStatus;
              if (cveStatus === 'Completed' && latestScanTimeStr) {
                summary = `Completed ${moment(
                  latestScanTimeStr.replace(/"/g, '')
                ).fromNow()}`;
              }
              return summary;
            },
            Cell: cell => {
              const {
                original: { vulnerability_scan_status_msg: reason = '' } = {},
              } = cell;
              return (
                <div>
                  <span> {cell.value} </span>
                  {reason && (
                    <span title={reason} className="fa fa-info-circle" />
                  )}
                </div>
              );
            },
          },
        ]}
        multiSelectOptions={{
          actions: [
            {
              name: 'Scan',
              IconComponent: DfDropDownMenu,
              componentParams: {
                alignment: 'right',
                label: 'Actions',
                options: this.nodeActionOptions,
              },
              onClick: () => ({}),
            },
          ],
          columnConfig: {
            accessor: 'image_name_with_tag',
          },
        }}
      />
    );
  }

  getFilters() {
    const { dispatch, registryId, filtersFormId } = this.props;

    const apiparams = {
      node_type: 'registry_image',
      registry_id: registryId,
      formId: filtersFormId,
    };
    return dispatch(enumerateFiltersAction(apiparams));
  }

  triggerRefresh() {
    const { toaster } = this.props;
    const { registryId, dispatch } = this.props;
    return dispatch(
      triggerRegistryRefreshAction({ registry_id: registryId })
    ).then(() => {
      this.getImages();
      this.getFilters();
      toaster('Registry images will be refreshed shortly');
    });
  }

  render() {
    const {
      registryIndexIm = Map(),
      registryType,
      registryId,
      loadingIm = Map(),
      lastUpdatedIm = Map(),
      isToasterVisible,
      initiatedByPollableIm = Map(),
      filtersFormId,
      uniqueImageCountIndexIm = Map(),
      updateInProgressIndexIm = Map(),
    } = this.props;
    const data = registryIndexIm.getIn([registryType, registryId], []);
    const total = uniqueImageCountIndexIm.getIn([registryType, registryId], 0);
    const updateInProgress = updateInProgressIndexIm.getIn([registryType, registryId], false);
    const initiatedByPollable = initiatedByPollableIm.getIn(
      [registryType, registryId],
      false
    );
    const loading =
      loadingIm.getIn([registryType, registryId], false) &&
      !initiatedByPollable;
    const lastUpdated = lastUpdatedIm.getIn([registryType, registryId], '');
    return (
      <div className="registry-image-list">
        <div className="d-flex justify-content-start">
          {lastUpdated && (
            <div className="refresh-container" style={{ marginTop: '30px' }}>
              <div className="message">
                <span
                  className="label-info fa fa-info-circle"
                  data-tip
                  data-event="click focus"
                  data-for="registry-info"
                  title={`Image details last updated ${lastUpdated}`}
                >
                  {' '}
                </span>
                <ReactTooltip
                  globalEventOff="click"
                  id="registry-info"
                  type="dark"
                  effect="solid"
                  place="bottom"
                >
                  {`Image details last updated ${lastUpdated}`}
                  <br />
                </ReactTooltip>
                <i
                  className="fa fa-lg fa-refresh"
                  onClick={this.triggerRefresh}
                  aria-hidden="true"
                />
              </div>
            </div>
          )}
          <NodesFilter
            formId={filtersFormId}
            nodeType="registry_image"
            extraArgs={{
              registry_id: registryId,
            }}
          />
        </div>
        <DfTableV2
          data={data}
          showPagination
          onPageChange={this.handlePageChange}
          manual
          totalRows={total}
          defaultPageSize={20}
          LoadingComponent={
            loading ? () => <AppLoader small style={loaderStyle} /> : undefined
          }
          noDataText={updateInProgress ? 'Registry update in progress. Please wait...' : undefined}
          renderRowSubComponent={({ row }) => this.renderSubComponent({ row })}
          name="registry-images"
          columns={[
            {
              Header: 'Image',
              accessor: 'image_name',
            },
            {
              Header: 'Total Tags',
              accessor: 'total_tags',
              maxWidth: 150,
            },
          ]}
        />
        {isToasterVisible && <NotificationToaster />}
      </div>
    );
  }
}

const mapStateToProps = (state, ownProps) => ({
  registryIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'filtered_images',
  ]),
  totalIndexIm: state.getIn(['cve', 'container_image_registry', 'total']),
  credentialsIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'credentials',
  ]),
  loadingIm: state.getIn(['cve', 'container_image_registry', 'loading']),
  initiatedByPollableIm: state.getIn([
    'cve',
    'container_image_registry',
    'initiatedByPollable',
  ]),
  lastUpdatedIm: state.getIn([
    'cve',
    'container_image_registry',
    'last_updated',
  ]),
  errorMessageIm: state.getIn([
    'cve',
    'container_image_registry',
    'error',
    'message',
  ]),
  uniqueImageCountIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'uniqueImageCount',
  ]),
  updateInProgressIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'updateInProgress',
  ]),
  isToasterVisible: state.get('isToasterVisible'),
  filterValues: createCustomSelector(`image-list-${ownProps.registryId}`)(
    state
  ),
  filtersFormId: `image-list-${ownProps.registryId}`,
});

const connectedComponent = connect(mapStateToProps, {
  scanRegistryImagesAction,
  listRegistryImagesAction,
  clearScanContainerImageRegistryAction,
  toaster,
})(RegistryImageList);
const pollableComponent = pollable({
  pollingIntervalInSecs: 5,
})(connectedComponent);
export default injectModalTrigger(pollableComponent);
