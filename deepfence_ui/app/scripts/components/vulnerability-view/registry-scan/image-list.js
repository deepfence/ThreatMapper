/* eslint-disable no-plusplus */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-unused-vars */
/* eslint-disable react/destructuring-assignment */
import React from 'react';
import moment from 'moment';
import { Map } from 'immutable';
import { connect } from 'react-redux';
import { DfTableV2 } from '../../common/df-table-v2'
import withMultiSelectColumn from '../../common/df-table/with-multi-select-column';
import NotificationToaster from '../../common/notification-toaster/notification-toaster';
import {
  scanRegistryImagesAction,
  listRegistryImagesAction,
  clearScanContainerImageRegistryAction,
  toaster,
  triggerRegistryRefreshAction,
  enumerateFiltersAction,
} from '../../../actions/app-actions';
import pollable from '../../common/header-view/pollable';
import injectModalTrigger from '../../common/generic-modal/modal-trigger-hoc';
import CVEScanForm from './cve-scan-form';
import NodesFilter from '../../../charts/nodes-filter';
import ImageTagsTable  from './imagetag-list';
import { nodeFilterValueSelector } from '../../../selectors/node-filters';

class RegistryImageList extends React.PureComponent {
  constructor(props) {
    super(props);
    this.scanRegistryImages = this.scanRegistryImages.bind(this);
    this.getImages = this.getImages.bind(this);
    this.showFormHandler = this.showFormHandler.bind(this);
    this.triggerStopCVEScanModal = this.triggerStopCVEScanModal.bind(this);
    this.bulkStopCVEScan = this.bulkStopCVEScan.bind(this);
    this.renderModalContent = this.renderModalContent.bind(this);
    this.tableChangeHandler = this.tableChangeHandler.bind(this);
    this.triggerRefresh = this.triggerRefresh.bind(this);
    this.getFilters = this.getFilters.bind(this);
    this.handlePageChange = this.handlePageChange.bind(this);
    this.nodeActionOptions = [
      {
        label: 'Start Vulnerability Scan',
        onClick: this.showFormHandler,
        enabled: true,
      },
      {
        label: 'Stop Vulnerability Scan',
        onClick: this.triggerStopCVEScanModal,
        enabled: true,
      },
    ];
  }

  componentDidMount() {
    const {registerPolling, startPolling } = this.props;
    registerPolling(this.getImages);
    startPolling();
  }

  UNSAFE_componentWillReceiveProps(newProps) {
    const {
      dispatch,
      errorMessageIm = Map(),
      registryType,
      registryId,
      initiatedByPollableIm,
      filterValues: newFilterValues,
    } = newProps;
    const newErrorMessage = errorMessageIm.getIn(
      [registryType, registryId],
      ''
    );
    const initiatedByPollable = initiatedByPollableIm.getIn(
      [registryType, registryId],
      false
    );
    if (newErrorMessage && !initiatedByPollable) {
      dispatch(toaster(newErrorMessage));
    }

    if (newFilterValues && this.props.filterValues !== newFilterValues) {
      const { updatePollParams } = this.props;
      updatePollParams({
        filters: newFilterValues,
      });
    }
  }

  componentWillUnmount() {
    // pollable: stop polling on unmount
    const { stopPolling } = this.props;
    stopPolling();
  }

  renderModalContent(props) {
    const { selectedDocIndex = {} } = props;

    return (
      <CVEScanForm
        onSubmit={valuesIm => {
          const { scanType, scheduleInterval } = valuesIm.toJS();
          const params = {
            selectedDocIndex,
            scanType,
            scheduleInterval,
          };
          this.scanRegistryImages(params);
        }}
      />
    );
  }

  showFormHandler(selectedDocIndex) {
    const { clearScanContainerImageRegistryAction: clearAction } = this.props;
    const modalProps = {
      title: 'Registry Vulnerability Scan',
      modalContent: this.renderModalContent,
      modalContentProps: {
        selectedDocIndex,
      },
      contentStyles: {
        width: '400px',
      },
      onHide: () => {
        clearAction();
      },
    };
    const { triggerModal } = this.props;
    triggerModal('GENERIC_MODAL', modalProps);
  }

  triggerStopCVEScanModal(selectedDocIndex) {
    const modalProps = {
      dialogTitle: 'Stop Vulnerability Scan',
      dialogBody:
        'This will only stop the scans that are in queued state. It will not stop scans that are currently running. Do you want to continue ?',
      confirmButtonText: 'Yes',
      cancelButtonText: 'No',
      onConfirmButtonClick: paramsIm =>
        this.bulkStopCVEScan(selectedDocIndex, paramsIm),
    };
    const { triggerModal } = this.props;
    return triggerModal('DIALOG_MODAL', modalProps);
  }

  getImages(inputParams = {}) {
    const {
      refresh = false,
      initiatedByPollable,
      page = 0,
      pageSize = 20,
      sorted = [],
    } = inputParams;

    const sortArr = sorted.map(el => ({
      sort_by: el.id,
      sort_order: el.desc ? 'desc' : 'asc',
    }));
    const sortField = sortArr.length ? sortArr[sortArr.length - 1] : {};
    const {
      listRegistryImagesAction: listAction,
      filterValues = {},
      registryId,
      registryType,
    } = this.props;

    const imageFilters = inputParams.filters || filterValues;
    const nonEmptyFilters = Object.keys(imageFilters)
      .filter(key => imageFilters[key].length)
      .reduce((acc, key) => {
        // replacing back the dot which was removed redux-form as it considers that a nested field.
        acc[[key.replace('-', '.')]] = imageFilters[key];
        return acc;
      }, {});
    const params = {
      registry_id: registryId,
      registryType,
      refresh,
      size: pageSize,
      start_index: page * pageSize,
      ...sortField,
      initiatedByPollable,
      filters: {
        ...nonEmptyFilters,
        type: 'registry_image',
      },
    };
    
    return listAction(params).then(() => this.getFilters());
  }

  bulkStopCVEScan(selectedDocIndex) {
    const {
      registryId,
      scanRegistryImagesAction: action,
      toaster: toast,
    } = this.props;

    const imageList = Object.keys(selectedDocIndex);

    const apiParams = {
      action: 'cve_scan_stop',
      node_type: 'registry_image',
      registry_images: {
        image_name_with_tag_list: imageList,
        registry_id: registryId,
      },
    };
    return action(apiParams).then(response => {
      const { success, error: apiError } = response;
      if (success) {
        toast('Request to stop vulnerability scan successfully queued');
      } else {
        toast(`ERROR: ${apiError.message}`);
      }
    });
  }

  renderSubComponent({ row }, data) {
    const imageTag = [];
    for (let i = 0; i < data.length; i++) {
      if (data[i].image_name === row.original.image_name) {
        imageTag.push(data[i]);
      }
    }
    return (
      <ImageTagsTable 
      imageTags={imageTag}
      nodeActionOptions={this.nodeActionOptions} />
    )
  }

  scanRegistryImages(params) {
    const {
      registryId,
      scanRegistryImagesAction: action,
      resetSelection,
    } = this.props;

    const { selectedDocIndex, scanType, scheduleInterval } = params;

    const imageList = Object.keys(selectedDocIndex);

    let apiAction = 'cve_scan_start';
    let actionArgs = {
      scan_type: scanType,
      resources: [],
    };
    if (scheduleInterval) {
      apiAction = 'schedule_vulnerability_scan';
      actionArgs = {
        cron: `0 0 */${scheduleInterval} * *`,
        scan_type: scanType,
        resources: [],
      };
    }
    const apiParams = {
      action: apiAction,
      node_type: 'registry_image',
      registry_images: {
        scan_type: scanType,
        image_name_with_tag_list: imageList,
        registry_id: registryId,
      },
      action_args: actionArgs,
    };

    const promise = action(apiParams);
    promise.then(() => resetSelection());
    return promise;
  }

  tableChangeHandler(params = {}) {
    // pollable: on any change in the DF Table params, update the polling params,
    // which will update and restart polling with new params.
    const { updatePollParams } = this.props;
    updatePollParams(params);
  }

  handlePageChange(pageNumber) {
    this.tableChangeHandler({
      page: pageNumber
    })
  }

  getFilters() {
    const { dispatch, registryId } = this.props;

    const apiparams = {
      node_type: 'registry_image',
      registry_id: registryId,
    };
    return dispatch(enumerateFiltersAction(apiparams));
  }

  triggerRefresh() {
    const { registryId, dispatch } = this.props;
    return dispatch(
      triggerRegistryRefreshAction({ registry_id: registryId })
    ).then(() => {
      this.getImages();
      this.getFilters();
    });
  }

  render() {
    const {
      registryIndexIm = Map(),
      totalIndexIm = Map(),
      registryType,
      registryId,
      loadingIm = Map(),
      lastUpdatedIm = Map(),
      isToasterVisible,
      initiatedByPollableIm = Map(),
    } = this.props;

    const data = registryIndexIm.getIn([registryType, registryId], []);
    const imageNames = data.map(d => d.image_name);
    const filtered = data.filter(({image_name}, index) => !imageNames.includes(image_name, index + 1));
    const total = totalIndexIm.getIn([registryType, registryId], []);
    const initiatedByPollable = initiatedByPollableIm.getIn(
      [registryType, registryId],
      false
    );
    const loading =
      loadingIm.getIn([registryType, registryId], false) &&
      !initiatedByPollable;
    const lastUpdated = lastUpdatedIm.getIn([registryType, registryId], '');
    return (
      <div className="registry-image-list">
        <div className="d-flex justify-content-start">
          {lastUpdated && (
            <div className="refresh-container" style={{ marginTop: '30px' }}>
              <div className="message">
                <span
                  className="label-info fa fa-info-circle"
                  title={`Image details last updated ${lastUpdated}`}
                >
                  {' '}
                </span>
                <i
                  className="fa fa-lg fa-refresh"
                  onClick={this.triggerRefresh}
                  aria-hidden="true"
                />
              </div>
            </div>
          )}
          <NodesFilter
            nodeType="registry_image"
            extraArgs={{
              registry_id: registryId,
            }}
          />
        </div>
        <DfTableV2
        data={filtered}
        showPagination
        manual
        renderRowSubComponent={({ row}) => this.renderSubComponent({ row }, data)}
        totalRows={filtered.length}
        defaultPageSize={20}
        name="registry-images"
        columns={[
          {
            Header: 'Image',
            accessor: 'image_name',
          },
          {
            Header: 'Platform',
            accessor: 'image_os',
            maxWidth: 150,
          },
        ]}
        columnCustomizable
        onPageChange={this.handlePageChange}
        onSortChange={(sorted) => {
          this.tableChangeHandler({
            sorted
          })
        }}
       />
        {isToasterVisible && <NotificationToaster />}
      </div>
    );
  }
}

const mapStateToProps = state => ({
  registryIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'filtered_images',
  ]),
  totalIndexIm: state.getIn(['cve', 'container_image_registry', 'total']),
  credentialsIndexIm: state.getIn([
    'cve',
    'container_image_registry',
    'credentials',
  ]),
  loadingIm: state.getIn(['cve', 'container_image_registry', 'loading']),
  initiatedByPollableIm: state.getIn([
    'cve',
    'container_image_registry',
    'initiatedByPollable',
  ]),
  lastUpdatedIm: state.getIn([
    'cve',
    'container_image_registry',
    'last_updated',
  ]),
  errorMessageIm: state.getIn([
    'cve',
    'container_image_registry',
    'error',
    'message',
  ]),
  isToasterVisible: state.get('isToasterVisible'),
  filterValues: nodeFilterValueSelector(state),
});

const connectedComponent = connect(mapStateToProps, {
  scanRegistryImagesAction,
  listRegistryImagesAction,
  clearScanContainerImageRegistryAction,
  toaster,
})(RegistryImageList);
const pollableComponent = pollable({
  pollingIntervalInSecs: 5,
})(connectedComponent);
export default injectModalTrigger(
  withMultiSelectColumn({
    name: 'registry_images',
    column: {
      name: 'Action',
      accessor: 'image_name_with_tag',
      minWidth: 40,
    },
  })(pollableComponent)
);
