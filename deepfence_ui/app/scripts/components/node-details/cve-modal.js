
/*eslint-disable*/
import React from 'react';
import {connect} from 'react-redux';
import {formValueSelector} from 'redux-form/immutable';
import moment from 'moment';
import Loader from '../loader';
import HorizontalLoader from '../common/app-loader/horizontal-dots-loader';
import classnames from 'classnames';
import {
      getAuthHeader, getRefreshToken, setCompanyLicenseStatus
} from '../../helpers/auth-helper';
import {backendElasticApiEndPoint, getApiPath, QueueCVEScan} from '../../utils/web-api-utils';
import {
  getCVEScanStatusAction,
  cveScanInterimStatusUpdateAction,
  startCVEBulkAction,
  getNodeStatusAction,
  startCVEScanAction,
} from '../../actions/app-actions';
import CVEScanForm from './cve-scan-form';
import pollable from '../common/header-view/pollable';

class CVE extends React.Component {
  constructor(details) {
    super();
    this.state = {};
    this.details   = details.details;
    this.cveStart  = this.cveStart.bind(this);
    this.startCVEBulk  = this.startCVEBulk.bind(this);
    this.startCVEScanGeneric = this.startCVEScanGeneric.bind(this);
    this.cveStop   = this.cveStop.bind(this, this.details);
    this.cveStatus = this.cveStatus.bind(this, this.details);
    this.getNodeStatus = this.getNodeStatus.bind(this);
    //extract image id
    if(this.details && (this.details.type=='container' || this.details.type=='container_image') && this.details.metadata){
        const imageMetaList = this.details.metadata.filter(el => el.id === 'docker_image_name' || el.id === 'docker_image_tag');
        const image_name = imageMetaList.filter(el => el.id === 'docker_image_name').pop() || {};
        const image_tag = imageMetaList.filter(el => el.id === 'docker_image_tag').pop() || {};
        this.imageId = `${image_name.value}:${image_tag.value}`;
    } else if (this.details && this.details.type=='host' && this.details.metadata){
      for(let i=0; i < this.details.metadata.length; i++){
        if(this.details.metadata[i].id == "host_name"){
          this.imageId = this.details.metadata[i].value.trim();
          break;
        }
      }
    }
  }


  // This action initiates CVE scan on the api server and from
  // there it goes to the probes
  startCVEScanGeneric(taglist, scanType, imageId) {
    const params = {
      taglist,
      scanType,
      nodeType: this.details.type,
      nodeId: this.details.id,
    }
    const {
      dispatch,
      details,
    } = this.props;

    const promise = dispatch(startCVEScanAction(params));
    promise.then(() => {
      const now = moment().unix();
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        message: "Starting vulnerability scan. Please wait.",
        summary: 'Starting',
        showStop: false,
        showInProgress: true,
        userClickedTimestamp: now,
      }));
    }, (error)=>{
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        error: {
          message: "Failed to start vulnerability scan",
          reason: error.responseText,
          showStart: true,
        },
        summary: 'Failed',
      }));
    });
    return promise;
  }

  startCVEBulk(taglist, scanType) {
    const params = {
      taglist,
      scanType,
      nodeType: this.details.type,
    }
    const {
      dispatch,
      startPolling,
    } = this.props;
    startPolling({taglist,});
    this.setState({
      showAggregates: true,
    });
    return dispatch(startCVEBulkAction(params));
  }

  cveStart(valuesImmutable) {
    let values = {}

    if (valuesImmutable.toJS) {
      values = valuesImmutable.toJS();
    }
     const {
       taglist = [],
       scanType,
       scanThisCluster = false,
       scanThisNamespace = false,
     } = values;

    const {details, dispatch, priorityValue} = this.props;

    const priorityValueCheck = !!(priorityValue && priorityValue[0] === 'priority');
    const metaIndex = details.metadata.reduce((acc, el) => {
      acc[el.id] = el;
      return acc;
    }, {});


    let node_id = ""
    if(this.details.type=='container' || this.details.type === 'container_image'){
      const {
        docker_image_name: {
          value: imageName = '',
        } = {},
        docker_image_tag: {
          value: imageTag = '',
        } = {},
      } = metaIndex;
      node_id = `${imageName}:${imageTag}`
    } else if (this.details.type=='host'){
      for(let i=0; i < details.metadata.length; i++){
        if(details.metadata[i].id == "host_name"){
          node_id = details.metadata[i].value.trim();
          break;
        }
      }
    }

    const now = moment().unix();
    dispatch(cveScanInterimStatusUpdateAction(node_id, {
      showInProgress: true,
      summary: 'Starting',
      showStop: false,
      userClickedTimestamp: now,
    }));

    if(this.details.type == 'container_image' && taglist.length == 0) {
      return this.startCVEScanGeneric(taglist, scanType, node_id);
    }
    this.is_cve_status_interval_paused = true;

    if(taglist && taglist.length > 0) {
      this.startCVEBulk(taglist, scanType).then(
        (data)=> {
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            message: "Starting vulnerability scan. Please wait.",
            summary: 'Starting',
            showStop: false,
            showInProgress: true,
            userClickedTimestamp: now,
          }));
        },
        (error)=>{
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            error: {
              message: "Failed to start vulnerability scan",
              reason: error.responseText,
              showStart: true,
            },
            summary: 'Failed',
          }));
          let cve_scan_message = "";
          if(error.status === 400){
            cve_scan_message = error.responseText
          }
          QueueCVEScan(node_id, "ERROR", cve_scan_message)
        }
      );
    } else {
      const reqUrl = `${backendElasticApiEndPoint()}/node/0/cve_scan_start?scope_id=${this.details.id}&node_type=${this.details.type}&priority=${priorityValueCheck}`;
      $.ajax({
        url: reqUrl,
        type: 'post',
        data: JSON.stringify({
          "scan_type": scanType,
          "scan_this_cluster": scanThisCluster,
          "scan_this_namespace": scanThisNamespace,
        }),
        headers: {
          'Authorization': getAuthHeader(),
          'Accept': 'application/json, text/javascript',   //If your header name has spaces or any other char not appropriate
          'Content-Type': 'application/json',
        },
        dataType: 'json',
        success: (data)=> {
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            message: "Starting vulnerability scan. Please wait.",
            summary: 'Starting',
            showStop: false,
            showInProgress: true,
            userClickedTimestamp: now,
          }));
        },
        error: (error)=>{
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            error: {
              message: "Failed to start vulnerability scan",
              reason: error.responseText,
              showStart: true,
            },
            summary: 'Failed',
          }));
          let cve_scan_message = ""
          if(error.status == 400){
            cve_scan_message = error.responseText
          }
          QueueCVEScan(node_id, "ERROR", cve_scan_message)
        }
      });
    }
    setTimeout(()=>{
      this.is_cve_status_interval_paused = false
    }, 3000)
  }

  getNodeStatus(params = {}) {
    const {
      currentTopologyId,
      dispatch,
    } = this.props;
    return dispatch(getNodeStatusAction({
      ...params,
      nodeType: currentTopologyId,
    }));
  }

  componentDidMount() {
	  this._ismounted = true;
    const {registerPolling} = this.props;
    registerPolling(this.getNodeStatus);
  }

  componentWillUnmount() {
	  this._ismounted = false;
  }

  cveStop() {
    const {details, dispatch} = this.props;
    const reqUrl = `${backendElasticApiEndPoint()}/node/0/cve_scan_stop?scope_id=${this.details.id}&node_type=${this.details.type}`;
    let node_id = ""
    if(this.details.type=='container'){
      for(let i=0; i < details.metadata.length; i++){
        if(details.metadata[i].id == "docker_image_name"){
          node_id = details.metadata[i].value.trim();
          break;
        }
      }
    } else if (this.details.type=='host'){
      for(let i=0; i < details.metadata.length; i++){
        if(details.metadata[i].id == "host_name"){
          node_id = details.metadata[i].value.trim();
          break;
        }
      }
    }

    const now = moment().unix();
    dispatch(cveScanInterimStatusUpdateAction(node_id, {
      showInProgress: true,
      summary: 'Stopping',
      userClickedTimestamp: now,
    }));
    this.is_cve_status_interval_paused = true
    setTimeout(()=>{
      this.is_cve_status_interval_paused = false
    }, 3000)
    $.ajax({
      url: reqUrl,
      type: 'post',
      headers: {
        Authorization: getAuthHeader(),
        Accept: 'application/json, text/javascript',   //If your header name has spaces or any other char not appropriate
      },
      dataType: 'json',
      success: function (data) {
        dispatch(cveScanInterimStatusUpdateAction(node_id, {
          message: "Stopping vulnerability scan. Please wait.",
          summary: 'Stopping',
          userClickedTimestamp: now,
        }));
      },
      error: (error)=>{
        dispatch(cveScanInterimStatusUpdateAction(node_id, {
          error: {
            message: "Failed to stop vulnerability scan",
          },
          showStart: true,
          summary: 'Failed',
        }));
        let cve_scan_message = "There was an error stopping the vulerability scan"
        QueueCVEScan(node_id, "ERROR", cve_scan_message)
      }
    });
  }

  cveStatus() {
    const {details} = this.props;
	  	 if(this.is_cve_status_interval_paused || !details) {
             return
         };

	  	let data = {}

      let node_id = ""

      if (!details.metadata) {
        dispatch(cveScanInterimStatusUpdateAction(node_id, {}));
        return
      }
	  	if(this.details.type=='container'){
        const imageMetaList = details.metadata.filter(el => el.id === 'docker_image_name' || el.id === 'docker_image_tag');
        const imageName = imageMetaList.filter(el => el.id === 'docker_image_name').pop() || {};
        const imageTag = imageMetaList.filter(el => el.id === 'docker_image_tag').pop() || {};
        node_id = `${imageName.value}:${imageTag.value}`;
	  	} else if (this.details.type=='host'){
            for(let i=0; i < details.metadata.length; i++){
                if(details.metadata[i].id == "host_name"){
                    node_id = details.metadata[i].value.trim();
                    break;
                }
            }
        } else {
            //incase its not of type container or host (hosted solutions), we show a generic message
            //and do not make a call
            dispatch(cveScanInterimStatusUpdateAction(node_id, {
              error: {
                message: "Never scanned for vulnerabilities",
              },
              showStart: true,
            }));
            return
        }

        this.props.dispatch(getCVEScanStatusAction(node_id));
  }
  render() {
    const {
      cveStore,
      details,
      aggregates = {},
    } =  this.props;


    const {
      parents = [],
    } = details;
    const podParents = parents.filter(parent => parent.topologyId === 'pods');
    const hasPodAsParent = podParents.length > 0;

    const {
      showAggregates,
    } = this.state;
    let data = {};
    let error = {};
    if (cveStore.status && this.imageId) {
      const currentImageStatus = cveStore.status[this.imageId] ? cveStore.status[this.imageId] : {};
      data = currentImageStatus.data ? currentImageStatus.data : {};
      error = currentImageStatus.error ? currentImageStatus.error : {};
    }
    const showData = !Object.keys(error).length > 0;
    /* eslint-enable */
    const {metadata} = details;
    const metadataIndex = metadata.reduce((acc, meta) => {
      acc[meta.id] = meta.value;
      return acc;
    }, {});
    const {
      user_defined_tags: userDefinedTags,
      kubernetes_cluster_id: kubeClusterId = '',
    } = metadataIndex;
    return (
      <div className="node-cve">
        <div className="cve-scan-status">
          <div className="text-message">
            {showData && data.message && (
            <span>
              {data.message}
            </span>
            )}
            {showData && data.error && (
            <span className="error-message">
              {data.error.message}
              {' '}
              <i>
                {' '}
                {data.error.reason}
                {' '}
              </i>
            </span>
            )}
            {error.message && (
            <span className="error-message">
              {error.message}
            </span>
            )}
          </div>
          {data.showInProgress
            && (
            <div className="pull-right">
              <div>
                <HorizontalLoader style={{top: '-50%', left: '90%'}} />
              </div>
            </div>
            )
          }
        </div>
        <div className="section-body">
          <div className="controls">
            {data.showStart
              && (
              <CVEScanForm
                onSubmit={this.cveStart}
                userDefinedTags={userDefinedTags}
                hasPodAsParent={hasPodAsParent}
                hasKubeClusterId={Boolean(kubeClusterId)}
              />
              )
            }
            {data.showStop
              && (
              <div>
                <button
                  type="button"
                  className="primary-btn full-width"
                  onClick={this.cveStop}
                  aria-hidden="true"
                >
                  Stop Scan
                </button>
              </div>
              )
            }
            {showAggregates
              && (
              <div className="scan-aggregates">
                <div className="info">
                  Vulnerability scan started on
                  {aggregates.TOTAL || 0}
                  {' '}
                  nodes
                </div>
                <div className="stats-container">
                  <div className="stat">
                    <div>{aggregates.REQUEST_QUEUED || 0}</div>
                    <div>Queued</div>
                  </div>
                  <div className="stat">
                    <div>{aggregates.IN_PROGRESS || 0}</div>
                    <div>On-going</div>
                  </div>
                  <div className="stat">
                    <div>{aggregates.ERROR || 0}</div>
                    <div>Error</div>
                  </div>
                  <div className="stat">
                    <div>{aggregates.COMPLETED || 0}</div>
                    <div>Completed</div>
                  </div>
                </div>
              </div>
              )
            }
          </div>
        </div>
      </div>
    );
  }
}

/* eslint-disable */
const cveScanFormSelector = formValueSelector('cve-scan');
function mapStateToProps(state) {
  const cve = state.get('cve');
  return {
    cveStore: cve ? cve.toJS() : {},
    nodes: state.get('nodes'),
    currentTopologyId: state.get('currentTopologyId'),
    aggregates: state.getIn(['cve', 'topology_cve_status', 'modal_view', 'aggregates']),
    priorityValue: cveScanFormSelector(state, 'priority'),
  }
}

const pollableCVE = pollable({
  pollingIntervalInSecs: 3,
})(CVE);

export default connect(mapStateToProps)(pollableCVE);
