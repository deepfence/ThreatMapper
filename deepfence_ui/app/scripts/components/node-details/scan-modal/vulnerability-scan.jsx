/* eslint-disable no-unneeded-ternary */
/* eslint-disable no-nested-ternary */
import React, { useCallback, useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import moment from 'moment';
import CveScanForm from './forms/cve-scan-form';
import { ScanFormAccordian, ScanHeadingDetails, ScanWraper } from './common';
import { cveScanInterimStatusUpdateAction, getNodeStatusAction, startCVEBulkAction, startCVEScanAction, stopCVEScanAction } from '../../../actions/app-actions';
import HorizontalLoader from '../../common/app-loader/horizontal-dots-loader';
import pollable from '../../common/header-view/pollable';

const VulnerabilityScan = ({
  details,
  imageId,
  startPolling,
  registerPolling,
  stopPolling
}) => {
  const {
    parents = [],
  } = details;
  const dispatch = useDispatch();
  const [showAggregates, setShowAggregates] = useState(false);
  const { cveStore, aggregates, currentTopologyId } = useSelector((state) => {
    const cve = state.get('cve');
    return {
      cveStore: cve ? cve.toJS() : {},
      currentTopologyId: state.get('currentTopologyId'),
      aggregates: state.getIn(['cve', 'topology_cve_status', 'modal_view', 'aggregates'], {}),
    }
  });

  const getNodeStatus = useCallback((params = {}) => {
    return dispatch(getNodeStatusAction({
      ...params,
      nodeType: currentTopologyId,
    }));
  }, [currentTopologyId]);

  useEffect(() => {
    registerPolling(getNodeStatus);
    return () => {
      stopPolling();
    };
  }, []);

  let data = {};
  let error = {};
  if (cveStore.status && imageId) {
    const currentImageStatus = cveStore.status[imageId] ? cveStore.status[imageId] : {};
    data = currentImageStatus.data ? currentImageStatus.data : {};
    error = currentImageStatus.error ? currentImageStatus.error : {};
  }
  const showData = !Object.keys(error).length > 0;
  const { metadata } = details;
  const metadataIndex = metadata.reduce((acc, meta) => {
    acc[meta.id] = meta.value;
    return acc;
  }, {});
  const podParents = parents.filter(parent => parent.topologyId === 'pods');
  const hasPodAsParent = podParents.length > 0;
  const {
    user_defined_tags: userDefinedTags,
    kubernetes_cluster_id: kubeClusterId = '',
  } = metadataIndex;

  const startCVEBulk = useCallback((taglist, scanType) => {
    const params = {
      taglist,
      scanType,
      nodeType: details.type,
    }
    dispatch(cveScanInterimStatusUpdateAction(imageId, {
      message: "Starting vulnerability scan. Please wait.",
      summary: 'Starting',
      showStop: false,
      showInProgress: true,
      userClickedTimestamp: moment().unix(),
    }));
    dispatch(startCVEBulkAction(params))
      .then(() => {
        startPolling({ taglist });
        setTimeout(() => {
          setShowAggregates(true);
        }, 5000);
      }).catch((error) => {
        dispatch(cveScanInterimStatusUpdateAction(imageId, {
          error: {
            message: "Failed to start vulnerability scan",
            reason: error.responseText,
            showStart: true,
          },
          summary: 'Failed',
        }));
      });
  }, [details, imageId]);

  const startCVEScanGeneric = useCallback(({
    taglist,
    scanType,
    imageId,
    scanThisCluster,
    scanThisNamespace,
    priority
  }) => {
    const params = {
      taglist,
      scanType,
      nodeType: details.type,
      nodeId: details.id,
      scanThisCluster,
      scanThisNamespace,
      priority
    }
    const promise = dispatch(startCVEScanAction(params));
    promise.then(() => {
      const now = moment().unix();
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        message: "Starting vulnerability scan. Please wait.",
        summary: 'Starting',
        showStop: false,
        showInProgress: true,
        userClickedTimestamp: now,
      }));
    }, (error) => {
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        error: {
          message: "Failed to start vulnerability scan",
          reason: error.responseText,
          showStart: true,
        },
        summary: 'Failed',
      }));
    });
    return promise;
  }, [details]);

  const cveStart = useCallback((valuesImmutable) => {
    let values = {}
    if (valuesImmutable.toJS) {
      values = valuesImmutable.toJS();
    }
    const {
      taglist = [],
      scanType,
      scanThisCluster = false,
      scanThisNamespace = false,
      priority
    } = values;
    const priorityValueCheck = !!(priority && priority.length > 0);
    const node_id = imageId;
    const now = moment().unix();

    dispatch(cveScanInterimStatusUpdateAction(node_id, {
      showInProgress: true,
      summary: 'Starting',
      showStop: false,
      userClickedTimestamp: now,
    }));

    if (taglist && taglist.length > 0) {
      startCVEBulk(taglist, scanType);
    } else {
      startCVEScanGeneric({ taglist, scanType, imageId: node_id, scanThisCluster, scanThisNamespace, priority: priorityValueCheck });
    }
  }, [details, imageId]);

  const cveStop = useCallback(() => {
    const now = moment().unix();
    dispatch(cveScanInterimStatusUpdateAction(imageId, {
      showInProgress: true,
      summary: 'Stopping',
      userClickedTimestamp: now,
    }));
    const promise = dispatch(stopCVEScanAction({
      nodeId: details.id,
      nodeType: details.type,
    }));
    setTimeout(() => {
      promise.then(() => {
        dispatch(cveScanInterimStatusUpdateAction(imageId, {
          message: "Stopping vulnerability scan. Please wait.",
          summary: 'Stopping',
          userClickedTimestamp: now,
        }));
      }).catch(() => {
        dispatch(cveScanInterimStatusUpdateAction(imageId, {
          error: {
            message: "Failed to stop vulnerability scan",
          },
          showStart: true,
          summary: 'Failed',
        }));
      });
    }, 5000);
  }, [imageId, details]);


  return (
    <ScanWraper>
      <ScanHeadingDetails
        headingText="Vulnerability Scan"
        statusText={
          error?.message?.length ? error?.message : (showData && data?.error?.message?.length ? data.error.message : (showData && data.message?.length ? data.message : ''))
        }
        isError={error?.message?.length ? true : (showData && data?.error?.message?.length ? true : false)}
        headingControl={
          <>
            {
              data.showStop && (
                <button
                  type="button"
                  className="primary-btn"
                  onClick={cveStop}
                  aria-hidden="true"
                >
                  Stop Scan
                </button>
              )
            }
            {data.showInProgress
              && (
                <HorizontalLoader style={{ position: 'static', fontSize: '26px', width: '40px' }} />
              )
            }
          </>
        }
      />
      <ScanFormAccordian label={!showAggregates && data.showStart ? "Configure and start" : null}>
        {
          !showAggregates && data.showStart && (
            <CveScanForm
              onSubmit={cveStart}
              userDefinedTags={userDefinedTags}
              hasPodAsParent={hasPodAsParent}
              hasKubeClusterId={Boolean(kubeClusterId)}
            />
          )
        }
        {showAggregates
          && (
            <div className="scan-aggregates">
              <div className="info">
                Vulnerability scan started on
                {' '}
                {aggregates.TOTAL || 0}
                {' '}
                nodes
              </div>
              <div className="stats-container">
                <div className="stat">
                  <div>{aggregates.REQUEST_QUEUED || 0}</div>
                  <div>Queued</div>
                </div>
                <div className="stat">
                  <div>{aggregates.IN_PROGRESS || 0}</div>
                  <div>On-going</div>
                </div>
                <div className="stat">
                  <div>{aggregates.ERROR || 0}</div>
                  <div>Error</div>
                </div>
                <div className="stat">
                  <div>{aggregates.COMPLETED || 0}</div>
                  <div>Completed</div>
                </div>
              </div>
            </div>
          )
        }
      </ScanFormAccordian>
    </ScanWraper>
  );
};


const PollableVunlerabilityScan = pollable({
  pollingIntervalInSecs: 3,
})(VulnerabilityScan);

export { PollableVunlerabilityScan as VulnerabilityScan }
