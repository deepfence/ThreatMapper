
import {
  Map
} from 'immutable';
import moment from 'moment';
import ActionTypes from '../constants/action-types';
import {
  CVE_SCAN_TYPE_OPTIONS
} from '../constants/menu-collection';
import {
  keyLabelizer
} from '../utils/transform-utils';

const formatCVEScanType = (cveScanType) => {
  let formatStr = '';
  if (cveScanType && cveScanType !== 'all') {
    const options = CVE_SCAN_TYPE_OPTIONS;
    for (let i = 0; i < options.length; i += 1) {
      if (options[i].value === cveScanType) {
        formatStr = `(${options[i].label})`;
        break;
      }
    }
  }
  return formatStr;
};

function CVEImageReportReducer(state = Map(), action) {
  const {
    initiatedByPollable
  } = action.input || {};
  switch (action.type) {
    case ActionTypes.CVE_IMAGE_REPORT_REQUEST: {
      state = state.setIn(['loading'], true);
      state = state.setIn(['initiatedByPollable'], initiatedByPollable);
      return state;
    }
    case ActionTypes.CVE_IMAGE_REPORT_SUCCESS: {
      const response = action.payload.data || {};
      const {total} = response;
      const imageList = response.data;
      const scanIndex = imageList.reduce((acc, image) => {
        const {scans} = image;
        const innerScanIndex = scans.reduce((innerAcc, scan) => {
          innerAcc[scan.scan_id] = scan;
          return innerAcc;
        }, {});
        acc = {
          ...acc,
          ...innerScanIndex
        };
        return acc;
      }, {});

      const prevReport = state.getIn(['report']);


      state = state.setIn(['loading'], false);
      state = state.setIn(['report'], {
        ...prevReport,
        ...scanIndex
      });
      state = state.setIn(['images'], imageList);
      state = state.setIn(['total'], total);
      return state;
    }
    case ActionTypes.CVE_IMAGE_REPORT_FAILURE: {
      // TODO: handle error state
      return state;
    }
    default:
      return state;
  }
}

function CVESeverityReportReducer(state = Map(), action) {
  const {
    initiatedByPollable
  } = action.input || {};
  switch (action.type) {
    case ActionTypes.CVE_SEVERITY_REPORT_REQUEST: {
      state = state.setIn(['loading'], true);
      state = state.setIn(['initiatedByPollable'], initiatedByPollable);
      return state;
    }

    case ActionTypes.CVE_SEVERITY_REPORT_SUCCESS: {
      state = state.setIn(['loading'], false);
      const response = action.payload.data || {};
      const labelledHostReport = Object.keys(response).map(key => ({
        label: key,
        value: keyLabelizer(response[key].severity),
      }));
      state = state.setIn(['report'], response);
      state = state.setIn(['labelled_report'], labelledHostReport);

      state = state.setIn(['summary_stats'], response);
      return state;
    }

    case ActionTypes.CVE_SEVERITY_REPORT_FAILURE: {
      // TODO: handle error state
      return state;
    }

    default:
      return state;
  }
}

function CVETypeReportReducer(state = Map(), action) {
  const {
    initiatedByPollable
  } = action.input || {};
  switch (action.type) {
    case ActionTypes.CVE_TYPE_REPORT_REQUEST: {
      state = state.setIn(['loading'], true);
      state = state.setIn(['initiatedByPollable'], initiatedByPollable);
      return state;
    }

    case ActionTypes.CVE_TYPE_REPORT_SUCCESS: {
      state = state.setIn(['loading'], false);
      const response = action.payload.data || {};
      const labelledHostReport = keyLabelizer(response);
      state = state.setIn(['report'], response);
      state = state.setIn(['labelled_report'], labelledHostReport);
      return state;
    }

    case ActionTypes.CVE_TYPE_REPORT_FAILURE: {
      // TODO: handle error state
      return state;
    }

    default:
      return state;
  }
}

function cveStatusTextUtil(cveStatus) {
  let data;
  if (!cveStatus) {
    return data;
  }

  const timestamp = cveStatus['@timestamp'];
  const cveScanMessage = cveStatus.cve_scan_message;
  const cveAction = cveStatus.action;
  const cveScanType = cveStatus.scan_type;

  /* eslint-disable no-fallthrough */
  switch (cveAction) {
    case 'WARN': {
      // fall through next case
    }
    case 'STARTED': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'In progress',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'SCAN_IN_PROGRESS': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'In progress',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'GENERATING_SBOM': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'Generating SBOM',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'GENERATED_SBOM': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'Generated SBOM',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'UPLOADING_IMAGE': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'Uploading image',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'UPLOAD_COMPLETE': {
      data = {
        message: `Vulnerability scan ${formatCVEScanType(cveScanType)} in progress`,
        showStop: false,
        showInProgress: true,
        summary: 'Upload complete',
        cveStatus: 'IN_PROGRESS',
      };
      break;
    }
    case 'COMPLETED': {
      data = {
        message: `Completed vulnerability scan ${formatCVEScanType(cveScanType)} on\n${moment(timestamp).format('MMMM Do YYYY, h:mm:ss a')}`,
        showStart: true,
        summary: `Completed ${moment(timestamp).fromNow()}`,
        cveStatus: 'COMPLETED',
      };
      break;
    }

    case 'ERROR': {
      data = {
        error: {
          message: 'Vulnerability scan failed.',
          reason: cveScanMessage,
        },
        showStart: true,
        summary: 'Failed',
        cveStatus: 'ERROR',
      };
      break;
    }

    case 'QUEUED': {
      data = {
        message: 'Vulnerability Scan is queued, Please wait.',
        summary: 'Queued',
        showStop: true,
        cveStatus: 'REQUEST_QUEUED',
      };
      break;
    }

    case 'REQUEST_STOP': {
      data = {
        message: 'Stopping vulnerability scan, Please wait.',
        summary: 'In progress',
        cveStatus: 'REQUEST_STOP',
      };
      break;
    }

    case 'STOPPED': {
      data = {
        message: 'Vulnerability scan stopped by user',
        showStart: true,
        summary: 'Interrupted',
        cveStatus: 'STOPPED',
      };
      break;
    }

    default: {
      data = {
        error: {
          message: 'Never scanned for vulnerabilities',
        },
        showStart: true,
        summary: 'Never Scanned',
      };
    }
  }
  /* eslint-enable */
  return data;
}

function topologyCVEStatusReducer(state = Map(), action) {
  switch (action.type) {
    case ActionTypes.GET_TOPOLOGY_CVE_STATUS_SUCCESS: {
      const {
        payload: {
          data: {
            cve: cveStatus,
          } = {},
        },
        input: {
          taglist, // hack: presence of taglist indicated request originated from CVE modal
        },
      } = action;
      const index = Object.keys(cveStatus).reduce((acc, nodeId) => {
        acc[nodeId] = cveStatusTextUtil(cveStatus[nodeId]) || {
          summary: 'Never scanned'
        };
        return acc;
      }, {});

      const indexAddress = [taglist ? 'modal_view' : 'topology_view', 'index'];
      state = state.setIn(indexAddress, index);

      // calculate stats
      const nodeStatusList = Object.keys(index).map(key => index[key]);
      const total = nodeStatusList.length;
      const aggregates = nodeStatusList.reduce((acc, el) => {
        if (acc[el.cveStatus]) {
          acc[el.cveStatus] += 1;
        } else {
          acc[el.cveStatus] = 1;
        }
        return acc;
      }, {});

      const aggregateAddress = [taglist ? 'modal_view' : 'topology_view', 'aggregates'];
      state = state.setIn(aggregateAddress, {
        ...aggregates,
        TOTAL: total,
      });

      return state;
    }

    default:
      return state;
  }
}

function topVulnerabledNodesReducer(state = Map(), action) {
  switch (action.type) {
    case ActionTypes.TOP_VULNERABLE_NODES_REQUEST: {
      state = state.set('loading', true);
      return state;
    }
    case ActionTypes.TOP_VULNERABLE_NODES_SUCCESS: {
      state = state.set('loading', false);
      const {
        payload: {
          data,
        } = {}
      } = action;
      // nodes
      state = state.setIn(['host_data'], data.host);
      // container
      state = state.setIn(['container_data'], data.container_image);
      return state;
    }
    case ActionTypes.TOP_VULNERABLE_NODES_FAILURE: {
      state = state.set('loading', false);
      return state;
    }
    default:
      return state;
  }
}

function containerImageRegistryReducer(state = Map({}), action) {
  switch (action.type) {
    case ActionTypes.SAVE_CONTAINER_IMAGE_REGISTRY_REQUEST: {
      const {
        input: {
          registry_type: registryType,
        },
      } = action;
      state = state.setIn(['add_credentials', 'loading', registryType], true);
      return state;
    }
    case ActionTypes.SAVE_CONTAINER_IMAGE_REGISTRY_SUCCESS: {
      const {
        payload: {
          success,
          error,
        } = {},
        input: {
          registry_type: registryType,
        },
      } = action;

      let errorMessage = '';
      if (error) {
        errorMessage = error.message || '';
      }

      state = state.setIn(['add_credentials', 'loading', registryType], false);
      if (success) {
        state = state.setIn(['add_credentials', 'message', registryType], 'Credentials saved successfully');
        state = state.deleteIn(['add_credentials', 'error', 'message', registryType]);
      } else {
        state = state.setIn(['add_credentials', 'error', 'message', registryType], errorMessage);
      }
      return state;
    }
    case ActionTypes.SAVE_CONTAINER_IMAGE_REGISTRY_FAILURE: {
      const {
        input: {
          registry_type: registryType,
        },
        payload: {
          // eslint-disable-next-line camelcase
          response: response_str,
        } = {},
      } = action;
      const response = JSON.parse(response_str);
      const {
        error,
      } = response;
      let errorMessage = 'Unknown error. Credentials failed to save.';
      if (error) {
        errorMessage = error.message || '';
      }
      state = state.setIn(['add_credentials', 'loading', registryType], false);
      state = state.setIn(['add_credentials', 'error', 'message', registryType], errorMessage);
      return state;
    }
    case ActionTypes.CLEAR_CONTAINER_IMAGE_REGISTRY_ADD_FORM: {
      state = state.deleteIn(['add_credentials', 'loading']);
      state = state.deleteIn(['add_credentials', 'error']);
      return state;
    }

    case ActionTypes.LIST_CONTAINER_IMAGE_REGISTRY_REQUEST: {
      const {
        input: {
          registryType,
        },
      } = action;
      state = state.setIn(['list_credentials', 'loading', registryType], true);
      return state;
    }
    case ActionTypes.LIST_CONTAINER_IMAGE_REGISTRY_SUCCESS: {
      const {
        payload: {
          success,
          data = []
        } = {},
        input: {
          registryType,
        },
      } = action;

      state = state.setIn(['list_credentials', 'loading', registryType], false);
      if (success) {
        state = state.setIn(['list_credentials', 'data', registryType], data);
        state = state.deleteIn(['list_credentials', 'error', 'message', registryType]);
      } else {
        state = state.setIn(['list_credentials', 'error', 'message', registryType], 'Failed to list credentials');
      }
      return state;
    }
    case ActionTypes.LIST_CONTAINER_IMAGE_REGISTRY_FAILURE: {
      const {
        input: {
          registryType,
        },
      } = action;
      state = state.setIn(['list_credentials', 'loading', registryType], false);
      state = state.setIn(['list_credentials', 'error', 'message', registryType], 'Unknown error. Failed to list credentials');
      return state;
    }
    case ActionTypes.CLEAR_CONTAINER_REGISTRY_SEARCH: {
      state = state.delete('search');
      return state;
    }
    case ActionTypes.UPDATE_CONTAINER_REGISTRY_SEARCH: {
      const {
        payload: {
          registryType,
          registryId,
          q = '',
          searchType,
        } = {},
      } = action;
      if (searchType) {
        state = state.setIn(['search', 'type'], searchType);
        state = state.deleteIn(['search', 'q']);
        return state;
      }

      const currentSearchType = state.getIn(['search', 'type']);

      state = state.setIn(['search', 'q'], q);

      const images = state.getIn(['images', registryType, registryId]);
      const normalisedImages = images.map(image => ({
        ...image,
        summary: image.cve_status.summary,
      }));
      const filteredImages = normalisedImages.filter((image) => {
        const value = image[currentSearchType] || '';
        return value.toLowerCase().includes(q.toLowerCase());
      });
      state = state.setIn(['filtered_images', registryType, registryId], filteredImages);
      return state;
    }
    case ActionTypes.LIST_REGISTRY_IMAGES_REQUEST: {
      const {
        initiatedByPollable
      } = action.input || {};
      const {
        input: {
          registryType,
          registry_id: registryId,
        },
      } = action;
      state = state.setIn(['loading', registryType, registryId], true);
      state = state.setIn(['initiatedByPollable', registryType, registryId], initiatedByPollable);
      state = state.deleteIn(['error', 'message', registryType]);
      return state;
    }

    case ActionTypes.LIST_REGISTRY_IMAGES_SUCCESS: {
      const {
        payload: {
          data,
          error,
        },
        input: {
          registryType,
          registry_id: registryId,
        },
      } = action;

      let errorMessage;
      let imageList = [];
      let lastUpdatedStr;
      let total = 0;
      let uniqueImageCount = 0;
      let totalScanned = 0;
      let totalProgress = 0;
      let registryUpdateInProgress = false;
      if (error) {
        errorMessage = error.message;
      }
      if (data) {
        imageList = data.data;
        lastUpdatedStr = data.last_updated;
        // eslint-disable-next-line prefer-destructuring
        total = data.total;
        uniqueImageCount = data.unique_images;
        totalScanned = data.total_scanned;
        totalProgress = data.scan_in_progress;
        registryUpdateInProgress = data.registry_update_in_progress;
    }

      let lastUpdated;
      if (lastUpdatedStr) {
        lastUpdated = moment(lastUpdatedStr).fromNow();
      }

      state = state.setIn(['loading', registryType, registryId], false);
      state = state.setIn(['images', registryType, registryId], imageList);
      state = state.setIn(['total', registryType, registryId], total);
      state = state.setIn(['uniqueImageCount', registryType, registryId], uniqueImageCount);
      state = state.setIn(['updateInProgress', registryType, registryId], registryUpdateInProgress);
      state = state.setIn(['totalScanned', registryType, registryId], totalScanned);
      state = state.setIn(['totalProgress', registryType, registryId], totalProgress);
      state = state.setIn(['filtered_images', registryType, registryId], imageList);
      state = state.setIn(['last_updated', registryType, registryId], lastUpdated);
      state = state.setIn(['error', 'message', registryType, registryId], errorMessage);
      return state;
    }

    case ActionTypes.LIST_REGISTRY_IMAGES_FAILURE: {
      const {
        payload: {
          error: {
            message: errorMessage = 'Sorry, something went wrong',
          } = {},
        },
        input: {
          registry_type: registryType,
        },
      } = action;
      state = state.setIn(['loading', registryType], false);
      state = state.setIn(['error', 'message', registryType], errorMessage);
      return state;
    }

    case ActionTypes.SCAN_REGISTRY_IMAGES_REQUEST: {
      state = state.setIn(['scan_registry', 'loading'], true);
      state = state.deleteIn(['scan_registry', 'error', 'message']);
      state = state.deleteIn(['scan_registry', 'message']);
      return state;
    }

    case ActionTypes.CLEAR_SCAN_REGISTRY_IMAGES: {
      state = state.deleteIn(['scan_registry', 'error', 'message']);
      state = state.deleteIn(['scan_registry', 'message']);
      state = state.setIn(['scan_registry', 'loading'], false);
      return state;
    }

    case ActionTypes.SCAN_REGISTRY_IMAGES_SUCCESS: {
      const {
        payload: {
          success,
          error,
        } = {},
        input: {
          action: apiAction,
        },
      } = action;

      state = state.setIn(['scan_registry', 'loading'], false);

      let errorMessage;
      if (error) {
        errorMessage = error.message;
      }

      if (success) {
        state = state.deleteIn(['scan_registry', 'error', 'message']);
        let message = 'Request to scan for vulnerabilities has been queued';
        if (apiAction === 'start_compliance_scan') {
          message = 'Request to scan for compliance has been queued';
        } else if (apiAction === 'schedule_compliance_scan') {
          message = 'Request to schedule compliance scan has been saved successfully';
        } else if (apiAction === 'schedule_vulnerability_scan') {
          message = 'Request to schedule vulnerability scan has been saved successfully';
        }
        state = state.setIn(['scan_registry', 'message'], message);
      } else {
        state = state.setIn(['scan_registry', 'error', 'message'], errorMessage);
        state = state.deleteIn(['scan_registry', 'message']);
      }
      return state;
    }

    case ActionTypes.SCAN_REGISTRY_IMAGES_FAILURE: {
      state = state.setIn(['scan_registry', 'loading'], false);
      state = state.setIn(['scan_registry', 'error', 'message'], 'Sorry, something went wrong');
      return state;
    }

    case ActionTypes.SECRETS_SCAN_REGISTRY_IMAGES_REQUEST: {
      state = state.setIn(['scan_registry', 'loading'], true);
      state = state.deleteIn(['scan_registry', 'error', 'message']);
      state = state.deleteIn(['scan_registry', 'message']);
      return state;
    }

    case ActionTypes.SECRETS_SCAN_REGISTRY_IMAGES_SUCCESS: {
      const {
        payload: {
          success,
          error,
        } = {},
      } = action;

      state = state.setIn(['scan_registry', 'loading'], false);

      let errorMessage;
      if (error) {
        errorMessage = error.message;
      }
      if (success) {
        state = state.deleteIn(['scan_registry', 'error', 'message']);
        const message = 'Request to scan has been queued';
        state = state.setIn(['scan_registry', 'message'], message);
      } else {
        state = state.setIn(['scan_registry', 'error', 'message'], errorMessage);
        state = state.deleteIn(['scan_registry', 'message']);
      }
      return state;
    }

    case ActionTypes.SECRETS_SCAN_REGISTRY_IMAGES_FAILURE: {
      state = state.setIn(['scan_registry', 'loading'], false);
      state = state.setIn(['scan_registry', 'error', 'message'], 'Sorry, something went wrong');
      return state;
    }

    default:
      return state;
  }
}

const initialState = Map();

function CVEReducer(state = initialState, action) {
  switch (action.type) {
    case ActionTypes.CVE_SCAN_STATUS_REQUEST: {
      const imageId = action.input;
      state = state.setIn(['status', imageId, 'loading'], true);
      state = state.setIn(['status', imageId, 'error'], {});
      return state;
    }

    case ActionTypes.CVE_SCAN_STATUS_SUCCESS: {
      const imageId = action.input;
      state = state.setIn(['status', imageId, 'loading'], false);
      const prevState = state.getIn(['status', imageId, 'data'], {});
      const now = moment().unix();
      const lastAction = prevState.userClickedTimestamp;
      if (now < lastAction + 10) {
        return state;
      }
      const cveStatus = action.payload.data;
      const data = cveStatusTextUtil(cveStatus);
      state = state.setIn(['status', imageId, 'response'], action.payload.data);
      state = state.setIn(['status', imageId, 'data'], data);
      return state;
    }

    case ActionTypes.CVE_SCAN_STATUS_FAILURE: {
      const imageId = action.input;
      state = state.setIn(['status', imageId, 'loading'], false);
      state = state.setIn(['status', imageId, 'error'], action.payload.error);
      return state;
    }

    case ActionTypes.CVE_SCAN_INTERIM_STATUS_UPDATE: {
      state = state.setIn(['status', action.imageId, 'data'], action.payload);
      return state;
    }

    case ActionTypes.GET_TOP_VULNERABLE_CONTAINERS_SUCCESS: {
      const {
        payload: {
          data = [],
        } = {},
      } = action;
      /* eslint-disable no-underscore-dangle */
      const topExpliots = data.data.map(el => ({
        cveId: el._source.cve_id,
        cveSeverity: el._source.cve_severity,
        rank: el._source.rank,
        score: el._source.cve_cvss_score,
        attackVector: el._source.attack_vector,
        liveConnection: el._source.live_connection,
        image: el._source.cve_container_image,
        vulnerableImages: el._source.vulnerable_images,
        description: el._source.cve_description,
        docId: el._id,
      }));
      const chartData = data.chart_data;
      /* eslint-disable */
      const countData = data?.count_data ?? {};
      state = state.setIn(['top_exploits'], topExpliots);
      state = state.setIn(['top_exploits_grouped'], chartData);
      state = state.setIn(['top_exploits_counts'], countData);
      return state;
    }

    case ActionTypes.GET_TOP_VULNERABLE_HOSTS_SUCCESS: {
      state = state.setIn(['top_host_stats'], action.payload.data);
      return state;
    }

    case ActionTypes.SAVE_IMAGE_REPORT_TABLE_STATE: {
      state = state.setIn(['image_report_table', 'state', 'page_number'], action.payload);
      return state;
    }

    case ActionTypes.GET_CVE_SEVERITY_PER_NODE_SUCCESS: {
      const {
        payload: {
          data: dataForAllScans,
        } = {},
        input: {
          filters: {
            cve_container_image: containerImage = '',
          } = {},
        } = {},
      } = action;
      const dataForAllScansSorted = dataForAllScans.sort((a, b) => {
        if (a['scan_id.keyword'] < b['scan_id.keyword']) {
          return 1;
        }
        if (a['scan_id.keyword'] > b['scan_id.keyword']) {
          return -1;
        }
        return 0;
      });

      let dataForLatestScan = {};
      if (dataForAllScansSorted.length > 0) {
        dataForLatestScan = dataForAllScansSorted[0];
      }
      const {
        aggs: severityBucket = [],
        'scan_id.keyword': scanId,
      } = dataForLatestScan;
      const formattedData = severityBucket.map(el => ({
        label: el['cve_severity.keyword'],
        value: el.count,
        scanId,
      }));
      state = state.setIn(['topology', 'node_cve_severity', containerImage], formattedData);
      return state;
    }

    default: {
      const currentCVESeverityReportViewState = state.get('severity_report_view');
      state = state.set('severity_report_view', CVESeverityReportReducer(
        currentCVESeverityReportViewState, action));

      const currentCVETypeReportViewState = state.get('cve_type_report_view');
      state = state.set('cve_type_report_view', CVETypeReportReducer(
        currentCVETypeReportViewState, action));

      const currentTopologyCVEStatusState = state.get('topology_cve_status');
      state = state.set('topology_cve_status', topologyCVEStatusReducer(
        currentTopologyCVEStatusState, action));

      const currentRegistryState = state.get('container_image_registry');
      state = state.set('container_image_registry', containerImageRegistryReducer(
        currentRegistryState, action));

      const currentCVEImageReportViewState = state.get('image_report_view');
      state = state.set('image_report_view', CVEImageReportReducer(currentCVEImageReportViewState, action));

      const currentTopVulnerableNodesState = state.get('top_vulnerable_nodes');
      state = state.set('top_vulnerable_nodes', topVulnerabledNodesReducer(currentTopVulnerableNodesState, action));
      return state;
    }
  }
}

export default CVEReducer;
