import '@/features/threat-graph/utils/vulnerability-threat-graph-custom-node';

import G6, { NodeConfig } from '@antv/g6';
import { useEffect, useRef, useState } from 'react';
import { HiOutlineInformationCircle } from 'react-icons/hi';
import { IconContext } from 'react-icons/lib';
import { generatePath, useFetcher } from 'react-router-dom';
import { useMeasure } from 'react-use';
import { CircleSpinner } from 'ui-components';

import {
  GraphVulnerabilityThreatGraph,
  GraphVulnerabilityThreatGraphRequestGraphTypeEnum,
} from '@/api/generated';
import { VulnerabilityThreatGraphLoaderData } from '@/features/threat-graph/data-components/vulnerabilityThreatGraphLoader';
import { toolbar, useG6raph } from '@/features/threat-graph/hooks/useG6Graph';
import { ThreatGraphNodeModelConfig } from '@/features/threat-graph/utils/vulnerability-threat-graph-custom-node';
import {
  EnhancedDetailedNodeSummary,
  G6GraphData,
} from '@/features/topology/types/graph';
import { getNodeImage } from '@/features/topology/utils/graph-styles';

type VulnerabilityThreatGraphFilters = {
  type: GraphVulnerabilityThreatGraphRequestGraphTypeEnum;
};

type ModelType = ThreatGraphNodeModelConfig & EnhancedDetailedNodeSummary;

const tooltip = new G6.Tooltip({
  offsetX: 10,
  offsetY: 10,
  itemTypes: ['node'],
  className: 'g6-tooltip-override',
  getContent: (e) => {
    const model = e?.item?.getModel() as ModelType | undefined;
    if (model?.id === 'in-the-internet') {
      return model.label;
    }
    return `
    <div role="tooltip" class="text-sm font-light text-gray-500 bg-white border border-gray-200 rounded-lg shadow-sm w-72 dark:bg-gray-800 dark:border-gray-600 dark:text-gray-400">
      <div class="p-3 space-y-2">
        <div>
          <h5 class="font-semibold text-gray-900 dark:text-gray-200">Name</h5>
          <div class="text-gray-900 dark:text-gray-400">${model?.id}</div>
        </div>

        
        <div>
          <h5 class="font-semibold text-gray-900 dark:text-gray-200">Attack Vector</h5>
          <div class="text-gray-900 dark:text-gray-400">${model?.cve_attack_vector}</div>
        </div>

        
        <div>
          <h5 class="font-semibold text-gray-900 dark:text-gray-200">Top CVEs</h5>
          <div class="text-gray-900 dark:text-gray-400">${model?.cve_id?.join(', ')}</div>
        </div>

        <div>
          <h5 class="font-semibold text-gray-900 dark:text-gray-200">PORTS</h5>
          <div class="text-gray-900 dark:text-gray-400">${model?.ports?.join(', ')}</div>
        </div>
      
      </div>
    </div>
    `;
  },
});

export const VulnerabilityThreatGraphComponent = ({
  filters,
}: {
  filters: VulnerabilityThreatGraphFilters;
}) => {
  const [measureRef, { height, width }] = useMeasure<HTMLDivElement>();
  const [container, setContainer] = useState<HTMLDivElement | null>(null);

  const { graph } = useG6raph(container, 'vulnerability-threat-graph-node', {
    plugins: [toolbar, tooltip],
    layout: {
      type: 'dagre',
      ranksep: 60,
      preventOverlap: true,
    },
  });
  const { data, loading, ...graphDataFunctions } = useVulnerabilityThreatGraphData();
  const graphDataFunctionsRef = useRef(graphDataFunctions);
  graphDataFunctionsRef.current = graphDataFunctions;

  useEffect(() => {
    graphDataFunctionsRef.current.getDataUpdates({ filters });
  }, [filters]);

  useEffect(() => {
    if (!graph || !data) return;
    graph.data(getGraphData(data));
    graph.render();
  }, [graph, data]);

  useEffect(() => {
    if (graph !== null && width && height) {
      graph.changeSize(width, height);
    }
  }, [width, height]);

  return (
    <div className="h-full w-full relative select-none" ref={measureRef}>
      <div className="absolute inset-0" ref={setContainer} />
      {loading ? (
        <div className="absolute bottom-32 left-6 text-gray-600 dark:text-gray-400">
          <CircleSpinner size="xl" />
        </div>
      ) : null}
      {!loading && isGraphEmpty(data) ? (
        <div className="absolute inset-0 flex gap-2 flex-col items-center justify-center p-6">
          <div>
            <IconContext.Provider
              value={{ className: 'text-[3rem] text-blue-600 dark:text-blue-400' }}
            >
              <HiOutlineInformationCircle />
            </IconContext.Provider>
          </div>
          <div className="text-gray-600 dark:text-gray-400 text-lg text-center">
            No attack paths found, please run some scans to discover attack paths.
          </div>
        </div>
      ) : null}
    </div>
  );
};

function isGraphEmpty(data?: VulnerabilityThreatGraphLoaderData): boolean {
  if (!data) return true;
  return !data || !data.length;
}

function getGraphData(data: GraphVulnerabilityThreatGraph[] | undefined) {
  const g6Data: G6GraphData = {
    nodes: [],
    edges: [],
  };
  const nodesMap = new Map<string, ThreatGraphNodeModelConfig | NodeConfig>();
  const edgesMap = new Map<
    string,
    {
      source: string;
      target: string;
      type: string;
      style: any;
    }
  >();

  nodesMap.set('in-the-internet', {
    id: 'in-the-internet',
    label: 'The Internet',
    size: 30,
    img: getNodeImage('pseudo')!,
    type: 'image',
    nonInteractive: true,
  });

  data?.forEach((paths) => {
    if (paths?.attack_path?.length) {
      const _paths = paths.attack_path;
      _paths.forEach((path) => {
        path.forEach((node, index) => {
          if (!nodesMap.has(node)) {
            nodesMap.set(node, {
              id: node,
              label: node,
              size: 20,
              img: getNodeImage('host')!,
              anchorPoints: [
                [0, 0.5],
                [0.5, 0.3],
              ],
              style: {
                fill: '#D03801',
                stroke: '#9CA3AF',
              },
              nonInteractive: true,
              cve_id: paths.cve_id,
              cve_attack_vector: paths.cve_attack_vector,
              ports: paths.ports,
            });
          }
          if (index) {
            const prev = path[index - 1];
            if (!edgesMap.has(`${prev}<->${node}`)) {
              edgesMap.set(`${prev}<->${node}`, {
                source: prev,
                target: node,
                type: 'cubic-vertical',
                style: {},
              });
            }
          }
        });
      });
    }
  });

  g6Data.nodes = Array.from(nodesMap.values());
  g6Data.edges = Array.from(edgesMap.values());

  return g6Data;
}

function useVulnerabilityThreatGraphData() {
  const fetcher = useFetcher<VulnerabilityThreatGraphLoaderData>();

  const getDataUpdates = ({
    filters,
  }: {
    filters: VulnerabilityThreatGraphFilters;
  }): void => {
    if (fetcher.state !== 'idle') return;

    const searchParams = new URLSearchParams();
    searchParams.set('type', filters.type);

    fetcher.load(
      generatePath(
        `/data-component/threat-graph-vulnerability?${searchParams.toString()}`,
      ),
    );
  };

  return {
    data: fetcher.data,
    getDataUpdates,
    loading: fetcher.state !== 'idle',
  };
}
