import cx from 'classnames';
import dayjs from 'dayjs';
import { toNumber } from 'lodash-es';
import React, {
  memo,
  Suspense,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { RefObject } from 'react';
import { IconContext } from 'react-icons';
import { FiFilter } from 'react-icons/fi';
import {
  HiArchive,
  HiArrowSmLeft,
  HiClock,
  HiDotsVertical,
  HiDownload,
  HiOutlineExclamationCircle,
  HiRefresh,
} from 'react-icons/hi';
import {
  ActionFunctionArgs,
  Await,
  Form,
  LoaderFunctionArgs,
  useFetcher,
  useLoaderData,
  useNavigation,
  useRevalidator,
  useSearchParams,
} from 'react-router-dom';
import { toast } from 'sonner';
import {
  Badge,
  Button,
  CircleSpinner,
  createColumnHelper,
  Dropdown,
  DropdownItem,
  IconButton,
  Modal,
  Table,
  TableSkeleton,
} from 'ui-components';
import { Checkbox, ModalHeader, Select, SelectItem, SlidingModal } from 'ui-components';

import {
  getScanResultsApiClient,
  getSearchApiClient,
  getTopologyApiClient,
} from '@/api/api';
import {
  ApiDocsBadRequestResponse,
  ModelScanResultsActionRequestScanTypeEnum,
  ModelVulnerabilityScanConfigLanguageLanguageEnum,
  SearchSearchScanReq,
} from '@/api/generated';
import { DFLink } from '@/components/DFLink';
import { VulnerabilityIcon } from '@/components/sideNavigation/icons/Vulnerability';
import { IconMapForNodeType } from '@/features/onboard/components/IconMapForNodeType';
import { ApiError, makeRequest } from '@/utils/api';
import { formatMilliseconds } from '@/utils/date';
import { typedDefer, TypedDeferredData } from '@/utils/router';

export interface FocusableElement {
  focus(options?: FocusOptions): void;
}

enum ActionEnumType {
  DELETE = 'delete',
  DOWNLOAD = 'download',
}

const PAGE_SIZE = 15;

const packages = [
  // {
  //   name: 'OS Packages',
  //   checked: false,
  //   value: ModelVulnerabilityScanConfigLanguageLanguageEnum.OsPackages,
  // },
  {
    name: 'Java',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Java,
  },
  {
    name: 'Javascript',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Javascript,
  },
  {
    name: 'Rust',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Rust,
  },
  {
    name: 'GoLang',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Golang,
  },
  {
    name: 'Ruby',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Ruby,
  },
  {
    name: 'Python',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Python,
  },
  {
    name: 'PHP',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Php,
  },
  {
    name: 'Dotnet',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Dotnet,
  },
];

enum NodeTypeEnum {
  Host = 'host',
  Container = 'container',
  Image = 'image',
}

type ScanResult = {
  nodeType: string;
  scanId: string;
  nodeId: string;
  nodeName: string;
  timestamp: number;
  status: string;
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  action?: null;
};

export type LoaderDataType = {
  error?: string;
  message?: string;
  data: Awaited<ReturnType<typeof getScans>>;
  containerImages?: {
    nodeId: string;
    containerImage: string;
  }[];
  containers?: {
    nodeId: string;
    nodeName: string;
  }[];
  hosts?: {
    nodeId: string;
    hostName: string;
  }[];
  clusters?: {
    clusterId: string;
    clusterName: string;
  }[];
};

const getStatusSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('status').map((status) => status.toUpperCase());
};
const getHostsSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('hosts');
};
const getContainersSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('containers');
};
const getContainerImagesSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('containerImages');
};
const getLanguagesSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('languages');
};
const getClustersSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('clusters');
};

async function getContainerImages(): Promise<LoaderDataType['containerImages']> {
  const result = await makeRequest({
    apiFunction: getSearchApiClient().searchContainerImages,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: ['node_id', 'docker_image_name', 'docker_image_tag'],
          },
          window: {
            offset: 0,
            size: 100,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<{ message?: string }>({});
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      containerImage: `${res.docker_image_name}:${res.docker_image_tag}`,
    };
  });
}

async function getContainers(): Promise<LoaderDataType['containers']> {
  const result = await makeRequest({
    apiFunction: getSearchApiClient().searchContainers,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 100,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<{
        message?: string;
      }>({});
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      nodeName: res.docker_container_name,
    };
  });
}

async function getHosts(): Promise<LoaderDataType['hosts']> {
  const result = await makeRequest({
    apiFunction: getSearchApiClient().searchHosts,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 100,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<{
        message?: string;
      }>({});
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      hostName: res.host_name,
    };
  });
}

async function getClusters(): Promise<LoaderDataType['clusters']> {
  const result = await makeRequest({
    apiFunction: getTopologyApiClient().getKubernetesTopologyGraph,
    apiArgs: [
      {
        graphTopologyFilters: {
          cloud_filter: [],
          field_filters: {
            contains_filter: { filter_in: null },
            order_filter: null as any,
            match_filter: {
              filter_in: {},
            },
          },
          host_filter: [],
          kubernetes_filter: [],
          pod_filter: [],
          region_filter: [],
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<{
        message?: string;
      }>({});
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
        });
      }
    },
  });
  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  const clusters = Object.keys(result.nodes)
    .map((key) => result.nodes[key])
    .filter((node) => {
      return node.type === 'kubernetes_cluster';
    })
    .sort((a, b) => {
      return (a.label ?? a.id ?? '').localeCompare(b.label ?? b.id ?? '');
    });
  return clusters.map((res) => {
    return {
      clusterId: res.id ?? 'N/A',
      clusterName: res.label ?? 'N/A',
    };
  });
}

async function getScans(
  nodeTypes: NodeTypeEnum[],
  searchParams: URLSearchParams,
): Promise<{
  scans: ScanResult[];
  currentPage: number;
  totalRows: number;
  message?: string;
}> {
  const results: {
    scans: ScanResult[];
    currentPage: number;
    totalRows: number;
    message?: string;
  } = {
    scans: [],
    currentPage: 1,
    totalRows: 0,
  };
  const status = getStatusSearch(searchParams);
  const scanFilters = {} as {
    status?: string[];
  };
  if (status.length > 0) {
    scanFilters.status = status;
  }

  const nodeFilters = {
    node_type: nodeTypes,
  } as {
    status?: string[];
    node_type?: string[];
    node_id?: string[];
    kubernetes_cluster_id?: string[];
  };
  const hosts = getHostsSearch(searchParams);
  const containers = getContainersSearch(searchParams);
  const images = getContainerImagesSearch(searchParams);
  const languages = getLanguagesSearch(searchParams);
  const clusters = getClustersSearch(searchParams);

  let page = toNumber(searchParams.get('page') ?? '0');
  page = isFinite(page) && !isNaN(page) && page > 0 ? page : 0;

  if (hosts && hosts?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id ? nodeFilters.node_id.concat(hosts) : hosts;
  }
  if (containers && containers?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(containers)
      : containers;
  }
  if (images && images?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(images)
      : images;
  }
  if (languages && languages?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(languages)
      : languages;
  }

  if (clusters && clusters?.length > 0) {
    nodeFilters.kubernetes_cluster_id = clusters;
  }

  const languageFilters = {} as {
    trigger_action: string[];
  };
  if (languages && languages.length > 0) {
    languageFilters.trigger_action = languages;
  }

  const scanRequestParams: SearchSearchScanReq = {
    node_filters: {
      filters: {
        contains_filter: {
          filter_in: {
            ...nodeFilters,
          },
        },
        order_filter: {
          order_field: '',
        },
        match_filter: {
          filter_in: {},
        },
      },
      in_field_filter: null,
    },
    scan_filters: {
      filters: {
        contains_filter: {
          filter_in: {
            ...scanFilters,
          },
        },
        order_filter: {
          order_field: '',
        },
        match_filter: { filter_in: { ...languageFilters } },
      },
      in_field_filter: null,
    },
    window: {
      offset: page * PAGE_SIZE,
      size: PAGE_SIZE,
    },
  };

  const result = await makeRequest({
    apiFunction: getSearchApiClient().searchVulnerabilityScan,
    apiArgs: [{ searchSearchScanReq: scanRequestParams }],
    errorHandler: async (r) => {
      const error = new ApiError(results);
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          ...results,
          message: modelResponse.message,
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  const countsResult = await makeRequest({
    apiFunction: getSearchApiClient().searchVulnerabilityScanCount,
    apiArgs: [
      {
        searchSearchScanReq: {
          ...scanRequestParams,
          window: {
            ...scanRequestParams.window,
            size: 10 * scanRequestParams.window.size,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError(results);
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          ...results,
          message: modelResponse.message,
        });
      }
    },
  });

  if (ApiError.isApiError(countsResult)) {
    throw countsResult.value();
  }

  if (result === null) {
    return results;
  }

  results.scans = result.map((res) => {
    const severities = res.severity_counts as {
      critical: number;
      high: number;
      medium: number;
      low: number;
    };
    severities.critical = severities.critical ?? 0;
    severities.high = severities.high ?? 0;
    severities.medium = severities.medium ?? 0;
    severities.low = severities.low ?? 0;

    return {
      nodeType: res.node_type,
      scanId: res.scan_id,
      nodeId: res.node_id,
      nodeName: res.node_id,
      timestamp: res.updated_at,
      status: res.status,
      total: severities.critical + severities.high + severities.medium + severities.low,
      critical: severities.critical,
      high: severities.high,
      medium: severities.medium,
      low: severities.low,
    };
  });

  results.currentPage = page;
  results.totalRows = page * PAGE_SIZE + countsResult.count;

  return results;
}

const loader = async ({
  request,
}: LoaderFunctionArgs): Promise<TypedDeferredData<LoaderDataType>> => {
  const searchParams = new URL(request.url).searchParams;

  const nodeType = searchParams.getAll('nodeType').length
    ? searchParams.getAll('nodeType')
    : ['container_image', 'container', 'host'];

  return typedDefer({
    data: getScans(nodeType as NodeTypeEnum[], searchParams),
    hosts: getHosts(),
    containers: getContainers(),
    containerImages: getContainerImages(),
    clusters: getClusters(),
  });
};

const action = async ({
  request,
}: ActionFunctionArgs): Promise<{
  url: string;
} | null> => {
  const formData = await request.formData();
  const actionType = formData.get('actionType');
  const scanId = formData.get('scanId');
  const nodeId = formData.get('nodeId');
  if (!actionType || !scanId || !nodeId) {
    throw new Error('Invalid action');
  }

  if (actionType === ActionEnumType.DELETE) {
    const result = await makeRequest({
      apiFunction: getScanResultsApiClient().deleteScanResult,
      apiArgs: [
        {
          modelScanResultsActionRequest: {
            doc_ids: [nodeId.toString()],
            scan_id: scanId.toString(),
            scan_type: ModelScanResultsActionRequestScanTypeEnum.VulnerabilityScan,
          },
        },
      ],
      errorHandler: async (r) => {
        const error = new ApiError<{
          message?: string;
        }>({});
        if (r.status === 400 || r.status === 409) {
          const modelResponse: ApiDocsBadRequestResponse = await r.json();
          return error.set({
            message: modelResponse.message ?? '',
          });
        }
      },
    });
    if (ApiError.isApiError(result)) {
      if (result.value()?.message !== undefined) {
        const message = result.value()?.message ?? 'Something went wrong';
        toast.error(message);
      }
    }

    toast.success('Scan deleted successfully');
    return null;
  } else if (actionType === ActionEnumType.DOWNLOAD) {
    const result = await makeRequest({
      apiFunction: getScanResultsApiClient().downloadScanResultsForScanID,
      apiArgs: [
        {
          scanId: scanId.toString(),
          scanType: ModelScanResultsActionRequestScanTypeEnum.VulnerabilityScan,
        },
      ],
      errorHandler: async (r) => {
        const error = new ApiError<{
          message?: string;
        }>({});
        if (r.status === 400 || r.status === 409) {
          const modelResponse: ApiDocsBadRequestResponse = await r.json();
          return error.set({
            message: modelResponse.message ?? '',
          });
        }
      },
    });
    if (ApiError.isApiError(result)) {
      if (result.value()?.message !== undefined) {
        const message = result.value()?.message ?? 'Something went wrong';
        toast.error(message);
      }
    }

    toast.success('Download is in progress');
    const a = document.createElement('a');
    const unixTime = dayjs(new Date()).unix();
    a.href = 'https://64.227.142.80/deepfence/openapi.json';
    a.download = `vulnerability_scan_${unixTime}`;
    a.click();
    // TODO: Add download link
    return null;
  }
  return null;
};

const FilterHeader = () => {
  return (
    <ModalHeader>
      <div className="flex gap-x-2 items-center p-4">
        <span className="font-medium text-lg">Filters</span>
      </div>
    </ModalHeader>
  );
};

const FilterModal = memo(
  ({
    showFilter,
    elementToFocusOnClose,
    setShowFilter,
  }: {
    elementToFocusOnClose: RefObject<FocusableElement> | null;
    showFilter: boolean;
    setShowFilter: React.Dispatch<React.SetStateAction<boolean>>;
  }) => {
    const loaderData = useLoaderData() as LoaderDataType;

    const [searchParams, setSearchParams] = useSearchParams();
    return (
      <SlidingModal
        header={<FilterHeader />}
        open={showFilter}
        onOpenChange={() => setShowFilter(false)}
        elementToFocusOnCloseRef={elementToFocusOnClose}
        width={'w-[400px]'}
      >
        <div className="dark:text-white p-4">
          <Form className="flex flex-col gap-y-6">
            <fieldset>
              <legend className="text-sm font-medium">Type</legend>
              <div className="flex gap-x-4">
                <Checkbox
                  label="Host"
                  checked={searchParams.getAll('nodeType').includes('host')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('nodeType', 'host');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('nodeType');
                        prev.delete('nodeType');
                        prevStatuses
                          .filter((status) => status !== 'host')
                          .forEach((status) => {
                            prev.append('nodeType', status);
                          });
                        prev.delete('page');
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="Container"
                  checked={searchParams.getAll('nodeType').includes('container')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('nodeType', 'container');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('nodeType');
                        prev.delete('nodeType');
                        prevStatuses
                          .filter((status) => status !== 'container')
                          .forEach((status) => {
                            prev.append('nodeType', status);
                          });
                        prev.delete('page');
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="Container Images"
                  checked={searchParams.getAll('nodeType').includes('container_image')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('nodeType', 'container_image');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('nodeType');
                        prev.delete('page');
                        prev.delete('nodeType');
                        prevStatuses
                          .filter((status) => status !== 'container_image')
                          .forEach((status) => {
                            prev.append('nodeType', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
              </div>
            </fieldset>
            <fieldset>
              <legend className="text-sm font-medium">Status</legend>
              <div className="flex gap-x-4">
                <Checkbox
                  label="Completed"
                  checked={searchParams.getAll('status').includes('complete')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'complete');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prev.delete('page');
                        prevStatuses
                          .filter((status) => status !== 'complete')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="In Progress"
                  checked={searchParams.getAll('status').includes('in_progress')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'in_progress');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prevStatuses
                          .filter((status) => status !== 'in_progress')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        prev.delete('page');
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="Error"
                  checked={searchParams.getAll('status').includes('error')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'error');
                        prev.delete('page');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prev.delete('page');
                        prevStatuses
                          .filter((status) => status !== 'error')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
              </div>
            </fieldset>
            <fieldset>
              <Select
                noPortal
                name="language"
                label={'Language'}
                placeholder="Select language"
                value={searchParams.getAll('languages')}
                sizing="xs"
                onChange={(value) => {
                  setSearchParams((prev) => {
                    prev.delete('languages');
                    value.forEach((language) => {
                      prev.append('languages', language);
                    });
                    prev.delete('page');
                    return prev;
                  });
                }}
              >
                {packages.map((pkg: { name: string }) => {
                  return <SelectItem value={pkg.name} key={pkg.name} />;
                })}
              </Select>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loaderData.hosts}>
                  {(resolvedData: LoaderDataType['hosts']) => {
                    return (
                      <Select
                        noPortal
                        name="host"
                        label={'Host'}
                        placeholder="Select host"
                        sizing="xs"
                        value={searchParams.getAll('hosts')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('hosts');
                            value.forEach((host) => {
                              prev.append('hosts', host);
                            });
                            prev.delete('page');
                            return prev;
                          });
                        }}
                      >
                        <>
                          {resolvedData?.map((host) => {
                            return (
                              <SelectItem value={host.nodeId} key={host.nodeId}>
                                {host.hostName}
                              </SelectItem>
                            );
                          })}
                        </>
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loaderData.containers}>
                  {(resolvedData: LoaderDataType['containers']) => {
                    return (
                      <Select
                        noPortal
                        name="container"
                        label={'Container'}
                        placeholder="Select container"
                        sizing="xs"
                        value={searchParams.getAll('containers')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('containers');
                            value.forEach((container) => {
                              prev.append('containers', container);
                            });
                            prev.delete('page');
                            return prev;
                          });
                        }}
                      >
                        {resolvedData?.map((container) => {
                          return (
                            <SelectItem value={container.nodeId} key={container.nodeId}>
                              {container.nodeName}
                            </SelectItem>
                          );
                        })}
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loaderData.containerImages}>
                  {(resolvedData: LoaderDataType['containerImages']) => {
                    return (
                      <Select
                        noPortal
                        name="image"
                        label={'Image'}
                        placeholder="Select image"
                        sizing="xs"
                        value={searchParams.getAll('containerImages')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('containerImages');
                            value.forEach((containerImage) => {
                              prev.append('containerImages', containerImage);
                            });
                            prev.delete('page');
                            return prev;
                          });
                        }}
                      >
                        {resolvedData?.map?.((image) => {
                          return (
                            <SelectItem value={image.nodeId} key={image.nodeId}>
                              {image.containerImage}
                            </SelectItem>
                          );
                        })}
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loaderData.clusters}>
                  {(resolvedData: LoaderDataType['clusters']) => {
                    return (
                      <Select
                        noPortal
                        name="cluster"
                        label={'Cluster'}
                        placeholder="Select cluster"
                        sizing="xs"
                        value={searchParams.getAll('clusters')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('clusters');
                            value.forEach((cluster) => {
                              prev.append('clusters', cluster);
                            });
                            prev.delete('page');
                            return prev;
                          });
                        }}
                      >
                        {resolvedData?.map?.((cluster) => {
                          return (
                            <SelectItem value={cluster.clusterId} key={cluster.clusterId}>
                              {cluster.clusterName}
                            </SelectItem>
                          );
                        })}
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
          </Form>
        </div>
      </SlidingModal>
    );
  },
);

const ScanFromDropdown = () => {
  return (
    <Dropdown
      triggerAsChild={true}
      content={
        <>
          <DropdownItem className="text-xs">Last 12 hours</DropdownItem>
          <DropdownItem className="text-xs">Last 24 hours</DropdownItem>
          <DropdownItem className="text-xs">Last 7 days</DropdownItem>
          <DropdownItem className="text-xs">Last 30 days</DropdownItem>
          <DropdownItem className="text-xs">Last 60 days</DropdownItem>
          <DropdownItem className="text-xs">Last 90 days</DropdownItem>
          <DropdownItem className="text-xs">Last 6 months</DropdownItem>
          <DropdownItem className="text-xs">Show All</DropdownItem>
        </>
      }
    >
      <IconButton
        className="ml-auto rounded-lg"
        size="xs"
        outline
        color="primary"
        icon={<HiClock />}
      />
    </Dropdown>
  );
};

const RefreshApiButton = () => {
  const revalidator = useRevalidator();
  return (
    <IconButton
      className="ml-auto rounded-lg"
      size="xs"
      outline
      color="primary"
      onClick={() => revalidator.revalidate()}
      loading={revalidator.state === 'loading'}
      icon={<HiRefresh />}
    />
  );
};

const DeleteConfirmationModal = ({
  showDialog,
  scanId,
  nodeId,
  setShowDialog,
}: {
  showDialog: boolean;
  scanId: string;
  nodeId: string;
  setShowDialog: React.Dispatch<React.SetStateAction<boolean>>;
}) => {
  const fetcher = useFetcher();

  const onDeleteAction = useCallback(
    (actionType: string) => {
      const formData = new FormData();
      formData.append('actionType', actionType);
      formData.append('scanId', scanId);
      formData.append('nodeId', nodeId);
      fetcher.submit(formData, {
        method: 'post',
      });
    },
    [scanId, nodeId, fetcher],
  );

  return (
    <Modal open={showDialog} onOpenChange={() => setShowDialog(false)}>
      <div className="grid place-items-center">
        <IconContext.Provider
          value={{
            className: 'mb-3 dark:text-red-600 text-red-400 w-[70px] h-[70px]',
          }}
        >
          <HiOutlineExclamationCircle />
        </IconContext.Provider>
        <h3 className="mb-4 font-normal text-center text-sm">
          Selected scan will be deleted.
          <br />
          <span>Are you sure you want to delete?</span>
        </h3>
        <div className="flex items-center justify-right gap-4">
          <Button size="xs" onClick={() => setShowDialog(false)}>
            No, cancel
          </Button>
          <Button
            size="xs"
            color="danger"
            onClick={() => {
              onDeleteAction(ActionEnumType.DELETE);
              setShowDialog(false);
            }}
          >
            Yes, I&apos;m sure
          </Button>
        </div>
      </div>
    </Modal>
  );
};

const ActionDropdown = ({
  icon,
  scanId,
  nodeId,
}: {
  icon: React.ReactNode;
  scanId: string;
  nodeId: string;
}) => {
  const fetcher = useFetcher();
  const [open, setOpen] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  const onDownloadAction = useCallback(() => {
    const formData = new FormData();
    formData.append('actionType', ActionEnumType.DOWNLOAD);
    formData.append('scanId', scanId);
    formData.append('nodeId', nodeId);
    fetcher.submit(formData, {
      method: 'post',
    });
  }, [scanId, nodeId, fetcher]);

  useEffect(() => {
    if (fetcher.state === 'idle') setOpen(false);
  }, [fetcher]);

  return (
    <>
      <DeleteConfirmationModal
        showDialog={showDeleteDialog}
        scanId={scanId}
        nodeId={nodeId}
        setShowDialog={setShowDeleteDialog}
      />
      <Dropdown
        triggerAsChild
        align="end"
        open={open}
        onOpenChange={setOpen}
        content={
          <>
            <DropdownItem
              className="text-sm"
              onClick={(e) => {
                e.preventDefault();
                onDownloadAction();
              }}
            >
              <span className="flex items-center gap-x-2">
                <HiDownload />
                Download
              </span>
            </DropdownItem>
            <DropdownItem className="text-sm" onClick={() => setShowDeleteDialog(true)}>
              <span className="flex items-center gap-x-2 text-red-700 dark:text-red-400">
                <IconContext.Provider
                  value={{ className: 'text-red-700 dark:text-red-400' }}
                >
                  <HiArchive />
                </IconContext.Provider>
                Delete
              </span>
            </DropdownItem>
          </>
        }
      >
        <Button className="ml-auto" size="xs" color="normal">
          <IconContext.Provider value={{ className: 'text-gray-700 dark:text-gray-400' }}>
            {icon}
          </IconContext.Provider>
        </Button>
      </Dropdown>
    </>
  );
};

const VulnerabilityScans = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const elementToFocusOnClose = useRef(null);
  const [showFilter, setShowFilter] = useState(false);
  const loaderData = useLoaderData() as LoaderDataType;
  const navigation = useNavigation();

  const columnHelper = createColumnHelper<ScanResult>();
  const columns = useMemo(() => {
    const columns = [
      columnHelper.accessor('nodeType', {
        enableSorting: false,
        cell: (info) => {
          return (
            <div className="flex items-center gap-x-2">
              <div className="bg-blue-100 dark:bg-blue-500/10 p-1.5 rounded-lg">
                <IconContext.Provider
                  value={{ className: 'w-4 h-4 text-blue-500 dark:text-blue-400' }}
                >
                  {IconMapForNodeType[info.getValue()]}
                </IconContext.Provider>
              </div>
              <span className="capitalize">{info.getValue()?.replaceAll('_', ' ')}</span>
            </div>
          );
        },
        header: () => 'Type',
        minSize: 300,
        size: 300,
        maxSize: 300,
      }),
      columnHelper.accessor('nodeName', {
        enableSorting: false,
        cell: (info) => {
          const isScanComplete = info.row.original.status?.toLowerCase() === 'complete';
          const WrapperComponent = ({ children }: { children: React.ReactNode }) => {
            if (isScanComplete) {
              return (
                <DFLink to={`/vulnerability/scan-results/${info.row.original.scanId}`}>
                  {children}
                </DFLink>
              );
            }
            return <>{children}</>;
          };
          return (
            <WrapperComponent>
              <div className="flex items-center gap-x-2">
                <IconContext.Provider
                  value={{ className: 'w-5 h-5 text-blue-500 dark:text-blue-400' }}
                >
                  {IconMapForNodeType[info.getValue()]}
                </IconContext.Provider>
                <span className="capitalize">{info.getValue()}</span>
              </div>
            </WrapperComponent>
          );
        },
        header: () => 'Name',
        minSize: 600,
        size: 600,
        maxSize: 600,
      }),
      columnHelper.accessor('timestamp', {
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <IconContext.Provider value={{ className: 'text-gray-400' }}>
              <HiClock />
            </IconContext.Provider>
            {formatMilliseconds(info.getValue())}
          </div>
        ),
        header: () => 'Timestamp',
        minSize: 300,
        size: 300,
        maxSize: 300,
      }),
      columnHelper.accessor('status', {
        enableSorting: false,
        cell: (info) => (
          <Badge
            label={info.getValue().toUpperCase().replaceAll('_', ' ')}
            className={cx({
              'bg-green-100 dark:bg-green-600/10 text-green-600 dark:text-green-400':
                info.getValue().toLowerCase() === 'complete',
              'bg-red-100 dark:bg-red-600/10 text-red-600 dark:text-red-400':
                info.getValue().toLowerCase() === 'error',
              'bg-blue-100 dark:bg-blue-600/10 text-blue-600 dark:text-blue-400':
                info.getValue().toLowerCase() === 'in_progress',
            })}
            size="sm"
          />
        ),
        header: () => 'Status',
        minSize: 200,
        size: 200,
        maxSize: 200,
      }),
      columnHelper.accessor('total', {
        enableSorting: true,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-5 h-5 text-gray-400">
              <VulnerabilityIcon />
            </div>
            {info.getValue()}
          </div>
        ),
        header: () => 'Total',
        minSize: 100,
        size: 150,
        maxSize: 150,
      }),
      columnHelper.accessor('critical', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-red-400 dark:bg-red-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 150,
        maxSize: 150,
      }),
      columnHelper.accessor('high', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-pink-400 dark:bg-pink-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('medium', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-blue-400 dark:bg-blue-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('low', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-yellow-300 dark:bg-yellow-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.display({
        id: 'actions',
        enableSorting: false,
        cell: (cell) => (
          <ActionDropdown
            icon={<HiDotsVertical />}
            scanId={cell.row.original.scanId}
            nodeId={cell.row.original.nodeId}
          />
        ),
        header: () => '',
        minSize: 10,
        size: 10,
        maxSize: 10,
      }),
    ];

    return columns;
  }, []);

  const isFilterApplied =
    searchParams.has('languages') ||
    searchParams.has('containerImages') ||
    searchParams.has('containers') ||
    searchParams.has('nodeType') ||
    searchParams.has('hosts') ||
    searchParams.has('clusters');

  return (
    <div>
      <FilterModal
        showFilter={showFilter}
        setShowFilter={setShowFilter}
        elementToFocusOnClose={elementToFocusOnClose.current}
      />
      <div className="flex p-1 pl-2 w-full items-center shadow bg-white dark:bg-gray-800">
        <DFLink
          to={'/vulnerability'}
          className="flex hover:no-underline items-center justify-center mr-2"
        >
          <IconContext.Provider
            value={{
              className: 'w-5 h-5 text-blue-600 dark:text-blue-500 ',
            }}
          >
            <HiArrowSmLeft />
          </IconContext.Provider>
        </DFLink>
        <span className="text-sm font-medium text-gray-700 dark:text-gray-200">
          VULNERABILITY SCANS
        </span>
        <span className="ml-2">
          {navigation.state === 'loading' ? <CircleSpinner size="xs" /> : null}
        </span>
        <div className="ml-auto flex gap-x-4">
          <ScanFromDropdown />
          <RefreshApiButton />
          <div className="relative gap-x-4">
            {isFilterApplied && (
              <span className="absolute -left-[2px] -top-[2px] inline-flex h-2 w-2 rounded-full bg-blue-400 opacity-75"></span>
            )}

            <IconButton
              className="ml-auto rounded-lg"
              size="xs"
              outline
              color="primary"
              ref={elementToFocusOnClose}
              onClick={() => {
                setShowFilter(true);
              }}
              icon={<FiFilter />}
            />
          </div>
        </div>
      </div>
      <div className="m-2">
        <Suspense fallback={<TableSkeleton columns={7} rows={20} size={'md'} />}>
          <Await resolve={loaderData.data}>
            {(resolvedData: LoaderDataType['data']) => {
              return (
                <Table
                  size="sm"
                  data={resolvedData.scans}
                  columns={columns}
                  enableSorting
                  enablePagination
                  manualPagination
                  totalRows={resolvedData.totalRows}
                  pageSize={PAGE_SIZE}
                  pageIndex={resolvedData.currentPage}
                  onPaginationChange={(updaterOrValue) => {
                    let newPageIndex = 0;
                    if (typeof updaterOrValue === 'function') {
                      newPageIndex = updaterOrValue({
                        pageIndex: resolvedData.currentPage,
                        pageSize: PAGE_SIZE,
                      }).pageIndex;
                    } else {
                      newPageIndex = updaterOrValue.pageIndex;
                    }
                    setSearchParams((prev) => {
                      prev.set('page', String(newPageIndex));
                      return prev;
                    });
                  }}
                />
              );
            }}
          </Await>
        </Suspense>
      </div>
    </div>
  );
};

export const module = {
  loader,
  action,
  element: <VulnerabilityScans />,
};
